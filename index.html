<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body>
  <section id="cap1">
    <h1>Capítulo 1 Introducción.</h1>
    <h2>1.1 Motivación y Objetivos.</h2>
    <p>El bobinado de filamentos es un proceso de fabricación de piezas y componentes compuestos que produce productos livianos y de alta resistencia. Se utiliza principalmente para la producción de piezas simétricas de eje, como COPV (Composite Over-wrapped Pressure Vessels: recipientes a presión de materiales compuestos bobinados), tanques de almacenamiento, diferentes tipos de tuberías de alta presión, ejes de transmisión, pértiga y muchos otros, debido a la cinemática del propio proceso, lo que facilita la fabricación de este tipo de geometrías. Sin embargo, también se puede utilizar para producir piezas no simétricas respecto de un eje con gran éxito y amplia implementación, como se puede observar en la fabricación de palas de turbinas eólicas<a  href="#$8" title="[8] Hugo Faria. Analytical and numerical modelling of the filament winding process. 2007.">[8]</a>.</p>
    <p>Debido a la relativa facilidad con la que se puede automatizar el proceso, ha demostrado ser no sólo un método de fabricación de alto rendimiento sino también muy rentable cuando se producen grandes cantidades. Debido a estos dos factores, este proceso ha sido ampliamente adoptado en industrias de todo el mundo y para una amplia variedad de aplicaciones <a  href="#$9" title="[9] L Ainsworth. The state of fillament winding. (March), 1971.">[9]</a>.</p>
    <p>El proceso utiliza un refuerzo continuo (fibra de vidrio, fibra de carbono, alambre, etc.) ya sea previamente impregnado (preimpregnado: termoestable o termoplástico) o impregnado localmente en un baño abierto o dispositivo cerrado antes de llegar al mandril (bobinado húmedo) con una matriz termoestable. que se coloca sobre un mandril giratorio y luego se cura. Dependiendo de cómo se aplique el refuerzo continuo sobre el mandril, se pueden realizar diferentes trayectorias y obtener diferentes patrones de bobinado que a su vez producen piezas con diferente apariencia y propiedades mecánicas.<a  href="#$10" title="[10] Donald V. Rosato and Dominick V. Rosatot. Reinforced Plastics Handbook Third edition. page 1113, 2004.">[10]</a><a  href="#$9" title="[9] L Ainsworth. The state of fillament winding. (March), 1971.">[9]</a></p>
    <p>En el INEGI (Institute of Science and Innovation in Mechanical and Industrial Engineering: Instituto de Ciencia e Innovación en Ingeniería Mecánica e Industrial) -Instituto donde se desarrolló la tesis- existe una larga trayectoria de trabajo en el bobinado de filamentos. A través de este trabajo, se ha estudiado e investigado a fondo mucha información sobre diferentes aspectos del proceso y han transformado al instituto en una referencia de excelencia en el desarrollo de bobinados de filamentos. La máquina bobinadora de filamentos que tiene a su disposición el INEGI es una Pultrex MODwind 1S 6NC (Figura 1.1) la cual cuenta con 6 ejes controlables y es capaz de producir la mayoría de piezas imaginables. Sin embargo, durante todo este trabajo, las trayectorias reales del refuerzo continuo nunca se estudiaron de cerca, lo que hizo que el instituto dependiera de software externo para diseñar las piezas producidas.</p>
    <img src="assets/images/image001.png" alt="Máquina Bobinadora de Filamentos de 6 ejes">
    <figura>Figura 1.1: Pultrex MODwind 1S 6NC - Máquina Bobinadora de Filamentos de 6 ejes presente en las instalaciones del INEGI.</figura>
    <p>El estudio de las trayectorias del refuerzo continuo sobre la superficie de un mandril es de vital importancia porque permite evaluar y determinar las trayectorias que proporcionan las mejores propiedades mecánicas dentro de los límites geométricos y físicos especificados por el diseñador.</p>
    <p>Por lo tanto, el objetivo de esta tesis es comprender, modelar y evaluar mejor los diferentes tipos de trayectorias que se pueden realizar a lo largo de las superficies de mandriles simétricos, interpretar cómo estos pueden usarse para producir piezas completas con diferentes patrones de bobinado y finalmente implementarlos en una máquina bobinadora de filamentos que producirá las piezas deseadas.</p>
    <p>Para lograr este objetivo, se propuso un código numérico que sería capaz de crear automáticamente las trayectorias para el refuerzo continuo de acuerdo con las especificaciones geométricas y materiales proporcionadas por el diseñador. Este código se denominó Pathwind y se desarrolló de acuerdo a lo que se determinó eran las necesidades específicas del INEGI. Para desarrollar un código funcional y robusto, era necesario el establecimiento e implementación de un modelo que pudiera realizar las siguientes tareas:</p>
    <ul>
      <li>describir diferentes caminos geodésicos a lo largo de las superficies de cilindros y conos truncados;</li>
      <li>describir diferentes caminos no geodésicos garantizando al mismo tiempo la estabilidad de la fibra (sin deslizamiento entre fibra y mandril o fibra y fibra) a lo largo de las superficies de cilindros y conos truncados;</li>
      <li>determinar diferentes patrones de bobinado para mandriles, anchos de cable y ángulos de bobinado específicos;</li>
      <li>determinar los movimientos de los ejes de una máquina bobinadora de filamentos y generar un código CNC para su controlador con el fin de producir piezas con un patrón previamente seleccionado;</li>
      <li>Intentar describir el camino de los filamentos real con diferentes tipos de secciones transversales y superposiciones de filamentos.</li>
    </ul>
    <p>Para el desarrollo del código y con el fin de probar primero los diferentes conceptos e ideas, se determinó que se aceptaba un primer enfoque de permitir únicamente mandriles que fueran cilindros o conos truncados. Esto también está en línea con los trabajos recientes que se desarrollan en el INEGI en bobinado de filamentos que habían sido específicos para diferentes tamaños y estratificaciones de tubos cilíndricos. Cualquier otra geometría de mandril con eje simétrico se puede discretizar en una multitud de cilindros y conos truncados y, por lo tanto, este enfoque se puede utilizar en el futuro para una solución más genérica.</p>
    <p>Este código fue desarrollado en MatlabTM.</p>
    <h2>1.2 Esquema de tesis.</h2>
    <p>La tesis se divide en siete capítulos y dos anexos:</p>
    <ul>
      <li>El Capítulo 1 presenta el problema y define los objetivos de la tesis, así como su estructura;</li>
      <li>El Capítulo 2 proporciona información general sobre el bobinado de filamentos e introduce los conceptos matemáticos necesarios para comprender el desarrollo del código;</li>
      <li>El Capítulo 3 describe y explica los modelos utilizados para caracterizar los caminos de los filamentos a lo largo de la superficie de un mandril y cómo se implementaron;</li>
      <li>El Capítulo 4 describe la máquina Bobinadora de Filamentos que se utilizó en el INEGI y brinda una solución de cómo deben moverse los diferentes ejes para producir los recorridos previamente definidos a lo largo de una superficie de mandril real;</li>
      <li>El capítulo 5 especifica de qué manera se puede describir el camino de los filamentos para caracterizar completa y verdaderamente su comportamiento;</li>
      <li>El Capítulo 6 presenta los resultados de varias pruebas virtuales sobre el código desarrollado y muestra una pieza bobinada con filamento real que se fabricó únicamente mediante el uso del código Pathwind, validándola así experimentalmente;</li>
      <li>El Capítulo 7 tiene las conclusiones de las diferentes partes del proyecto y presenta el trabajo futuro que aún debe abordarse;</li>
      <li>El Apéndice A muestra el código MatlabTM que se produjo para esta tesis:
        <ul>
          <li>- A.1 es el código del programa principal Pathwind, A.2 es una función utilizada por el programa principal y produce las formas fundamentales y coeficientes de Christoffel de la superficie del mandril y A.3 es un algoritmo de determinación de patrones <a  href="#$11" title="[11] B S Johansen, Aa Lystrup, and M T Jensen. CADPATH: A complete program for the CAD-, CAE- and CAM-winding of advanced fibre composites. Journal of Materials Processing Technology, 300(3-4):194-200, 1998.">[11]</a>;</li>
          <li>
            - El Apéndice B es un manual de usuario sencillo que explica cómo utilizar el programa Pathwind.
          </li>
        </ul>
      </li>
    </ul>
  </section>
  <section id="cap2">
    <h1>Capítulo 2: Revisión de la literatura.</h1>
    <h2>2.1 Introducción al bobinado de filamentos.</h2>
    <p>El bobinado de filamentos comenzó a utilizarse en la década de 1950 y es uno de los métodos más antiguos para procesar compuestos. Por su sencillez, fue uno de los primeros en automatizarse y por tanto uno de los primeros en poder garantizar resultados consistentes a sus piezas. Como resultado de esta simplicidad y facilidad de automatización, sigue siendo uno de los procesos más competitivos en la fabricación de piezas ligeras de calidad, además de ser altamente rentable <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>.</p>
    <p>Las primeras piezas de bobinado de filamento fueron las carcasas de los motores de cohetes en la década de 1950 y, para automatizar este proceso, se desarrollaron las primeras máquinas de bobinado de filamento. Se trataba de máquinas simples de 2 ejes (la rotación del husillo y la traslación del carro) que fueron adaptadas de los tornos (produciendo la bobinadora de filamentos tipo torno o bobinadora de torno). A partir del torno bobinador se realizaron mejoras para abrir la posibilidad de crear piezas diferentes y más complejas. En consecuencia, se introdujeron nuevos ejes empezando por el carro transversal, aunque todavía se producían únicamente piezas con ejes simétricos. A partir de entonces, se intentaron diferentes configuraciones para las máquinas de bobinado de filamentos y después de la bobinadora de torno vinieron la bobinadora polar, la bobinadora de pista y la bobinadora de tambor, por ejemplo <a  href="#$9" title="[9] L Ainsworth. The state of fillament winding. (March), 1971.">[9]</a><a  href="#$10" title="[10] Donald V. Rosato and Dominick V. Rosatot. Reinforced Plastics Handbook Third edition. page 1113, 2004.">[10]</a>.</p>
    <img src="assets/images/image002.png" alt="Bobinadora de torno simple">
    <figura>Figura 2.1: Bobinadora de torno simple <a  href="#$1" title="[1] Alting L. Todd RH, Allen DK. Fundamental Principles of Manufacturing Processes. New York: Industrial Press Inc. 1994.">[1]</a></figura>
    <p>Durante la década de 1960, la industria aeroespacial transformó la industria de los compuestos y comenzó a invertir fuertemente en su investigación. Con esta investigación llegó el surgimiento de los recipientes a presión compuestos bobinados (COPV), que permitían presiones internas mucho mayores y al mismo tiempo pesaban menos que sus predecesores metálicos. Obviamente, esto fue muy apreciado en el diseño de cohetes y desde entonces se ha utilizado COPV en sus diseños <a  href="#$1" title="[1] Alting L. Todd RH, Allen DK. Fundamental Principles of Manufacturing Processes. New York: Industrial Press Inc. 1994.">[1]</a>.</p>
    <p>Las industrias del deporte y la automoción también han sido importantes patrocinadoras del proceso de fabricación de bobinados de filamentos y lo han adoptado para una variedad de productos. Como se ha comentado anteriormente, los ejes de transmisión se han fabricado de esta forma, especialmente para vehículos de carreras, reduciendo el peso y aumentando las prestaciones. Las pértigas de salto con pértiga ahora se fabrican exclusivamente mediante bobinado de filamentos, ya que es posible controlar la elasticidad y rigidez alterando los patrones de bobinado. Los palos de golf fabricados de esta manera también se han adoptado ampliamente en los últimos años, lo que proporciona otra industria más donde esta tecnología puede crecer. Todos estos productos son piezas enrolladas con filamentos cilíndricas o cónicas.</p>
    <p>La llegada de la tecnología informática y CNC supuso un gran avance en el bobinado de filamentos. Otorgó la capacidad de controlar mejor la colocación de las fibras y la precisión posicional, un mayor control de la velocidad y la posibilidad de interacción entre el software de simulación recién inventado y la máquina permitió realizar formas y formas más complejas. A lo largo de los años, se desarrollaron muchos software y entornos CAD/CAM que permitirían al usuario de una máquina bobinadora de filamentos controlada por CNC la posibilidad de diseñar piezas para diferentes formas de mandril y producir sus propias piezas <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>.</p>
    <p>Algunos de los software CAD/CAM existentes para aplicaciones de bobinado de filamentos son: CadFilTM, CadWindTM, FiberGraphixTM, CadPathTM y ComposicaDTM. Estos software proporciona diversos grados de control sobre el proceso de diseño y diferentes aplicaciones, tales como: mandriles con eje simétrico y no simétrico (incluidos codos y uniones en T) <a  href="#$13" title="[13] Johan Scholliers and Hendrik Van Brussel. Computer-integrated filament winding: computer-integrated design, robotic filament winding and robotic quality control. Composites Manufacturing, 5(1):15-23, 1994.">[13]</a> <a  href="#$14" title="[14] Haisheng Li, Youdong Liang, and Hujun Bao. CAM system for filament winding on elbows. Journal of Materials Processing Technology, 161:491-496, 2005.">[14]</a>, salida de malla FEA (Finite Element Analysis: análisis de elementos finitos) , bases de datos de materiales incorporadas, visualización gráfica del proceso y producto final, interfaces gráficas de usuario, salida de la máquina con optimización de tiempo y velocidad. Además de estos software disponibles, a lo largo de los años muchas instituciones y empresas han desarrollado su propio software ya sea para uso personal permanente o simplemente con fines de investigación. La mejora constante del software CAD para el bobinado de filamentos ha ayudado a avanzar la industria y aumentar las posibles aplicaciones del propio proceso de fabricación.</p>
    <h2>2.2 Trayectorias y geometría diferencial.</h2>
    <h3>2.2.1 Formas fundamentales de las superficies.</h3>
    <p>Las formas fundamentales de una superficie permiten el cálculo de la curvatura y otras propiedades métricas.</p>
    <p>Se consideró que una superficie tridimensional S puede parametrizarse como una función vectorial de dos parámetros reales independientes u y v de la siguiente manera:</p>
    <img src="assets/images/image003.png" alt="">
    <p>La longitud del arco de una curva que pertenece a esta superficie viene dada por <a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a><a  href="#$16" title="[16] Andrew Russell Forsyth. Lectures on the differential geometry of curves and surfaces. pages xxiii, 525 p., 1912.">[16]</a><a  href="#$17" title="[17] Toponogov Rovenski. Differential geometry of curves and surfaces. 1976.">[17]</a><a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a><a  href="#$19" title="[19] John Oprea. Differential Geometry and its Applications. 2007.">[19]</a>:</p>
    <img src="assets/images/image004.png" alt="">
    <p>Los diferenciales encontrados en la ecuación 2.2 se pueden expresar de la siguiente manera <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a>:</p>
    <img src="assets/images/image005.png" alt="">
    <p>donde # es un símbolo general que representa x, y o z.</p>
    <p>De las ecuaciones 2.2 y 2.3 obtenemos lo siguiente:</p>
    <img src="assets/images/image006.png" alt="">
    <p>dónde:</p>
    <img src="assets/images/image007.png" alt="">
    <p>Los tres coeficientes que se muestran en las ecuaciones 2.5, 2.6 y 2.7 (E, F y G) son los coeficientes de la primera forma fundamental. Donde E representa la métrica en dirección meridional y G representa la métrica en dirección paralela. Su y Sv son las derivadas del vector de superficie S con respecto a u y v respectivamente <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a><a  href="#$16" title="[16] Andrew Russell Forsyth. Lectures on the differential geometry of curves and surfaces. pages xxiii, 525 p., 1912.">[16]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$19" title="[19] John Oprea. Differential Geometry and its Applications. 2007.">[19]</a>.</p>
    <p>Los coeficientes de la segunda forma fundamental también serán importantes en la derivación de curvaturas y se muestran a continuación:</p>
    <img src="assets/images/image008.png" alt="">
    <p>Dado que las superficies simétricas de eje tienen una dirección u que es perpendicular a la dirección v, por definición F será cero. Si consideramos nuestro caso de una superficie eje simétrica (capa de revolución), podemos redefinir nuestra superficie y determinar los valores de las formas fundamentales <a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>:</p>
    <img src="assets/images/image009.png" alt="">
    <h3>2.2.2 Geodésicas</h3>
    <p>Las geodésicas son una clase de curvas que generalmente se describen como el camino más corto a lo largo de una superficie entre dos puntos. A menudo se describe imaginando que usted conduce un automóvil sobre la superficie de la tierra y avanza en línea recta. Aunque en realidad no vayas en línea recta, seguirás tomando el camino más corto. La importancia de los caminos geodésicos para el bobinado de filamentos es bastante simple: en los caminos geodésicos no se aplican fuerzas laterales de ningún tipo, las únicas fuerzas aplicadas serán las normales a la superficie y, por lo tanto, se evitará el deslizamiento de la fibra.</p>
    <p>Como ejemplo, las geodésicas a lo largo de una esfera son sus círculos máximos (círculos ecuatoriales en los que el centro coincide con el centro de la esfera) y en un cilindro forman una hélice. Para encontrar el camino mínimo, se propone una función que relaciona u y v de manera que minimice la longitud del arco <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>:</p>
    <img src="assets/images/image010.png" alt="">
    <p>Si expresamos du dv como v0 y fijamos los puntos inicial y final:</p>
    <img src="assets/images/image011.png" alt="">
    <p>Y como la integral será cero independientemente del cambio a δv, esto nos lleva a la ecuación de Euler-Lagrange <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>:</p>
    <img src="assets/images/image012.png" alt="">
    <p>Reemplazando la función f con la expresión para la longitud de la curva (expresión 2.4) y después de reordenar, obtenemos <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>:</p>
    <img src="assets/images/image013.png" alt="">
    <p>Donde Ev, Fv y Gv son las derivadas de E, F y G con respecto a v respectivamente. Para resolver la ecuación anterior y dado que las formas fundamentales suelen estar en función tanto de u como de v, se suelen emplear métodos numéricos. En el caso de las geodésicas, este problema suele resolverse utilizando los coeficientes de Christoffel que se muestran a continuación <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>:</p>
    <img src="assets/images/image014.png" alt="">
    <img src="assets/images/image015.png" alt="">
    <h3>2.2.3 Curvaturas</h3>
    <p>La curvatura se puede explicar como la tendencia de una línea a cambiar de dirección. Si la curvatura de una curva tiene mayor valor, es menos recta.</p>
    <p>Si consideramos un ángulo α entre la dirección de la fibra y el meridional, dependiendo de este ángulo, la curvatura kn que es normal a la superficie tendrá un valor máximo y un mínimo que se conocen como curvaturas principales y en el caso del eje- Superficies simétricas son las curvaturas meridianas y paralelas. Las curvaturas principales se pueden relacionar con la curvatura gaussiana (K) y con la curvatura media (H) mediante la primera y segunda formas fundamentales <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$16" title="[16] Andrew Russell Forsyth. Lectures on the differential geometry of curves and surfaces. pages xxiii, 525 p., 1912.">[16]</a><a  href="#$19" title="[19] John Oprea. Differential Geometry and its Applications. 2007.">[19]</a>:</p>
    <img src="assets/images/image016.png" alt="">
    <p>Ahora podemos expresar la curvatura de la fibra colocada encima y normal a nuestra superficie simétrica del eje de la siguiente manera:</p>
    <img src="assets/images/image017.png" alt="">
    <p>Donde k1 es la curvatura meridional km y puede expresarse en términos de la primera y segunda forma fundamental <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image018.png" alt="">
    <p>Y k2 es la curvatura paralela kp y también se puede expresar en términos de la primera y segunda forma fundamental <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image019.png" alt="">
    <p>Ahora introduciré el concepto de curvatura geodésica, kg. Es una curvatura tangencial a la superficie. Para que una curva sea geodésica, su curvatura geodésica debe ser igual a 0. La curvatura geodésica se puede expresar como <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a>:</p>
    <img src="assets/images/image020.png" alt="">
    <p>O:</p>
    <img src="assets/images/image021.png" alt="">
    <p>Y como formula la fórmula de Liouville <a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>:</p>
    <img src="assets/images/image022.png" alt="">
    <p>Y podemos expresar la curvatura total mediante la curvatura normal y la curvatura geodésica:</p>
    <img src="assets/images/image023.png" alt="">
    <h3>2.2.4 Geodésicas revisadas</h3>
    <p>Ahora se puede determinar una geodésica expresando primero las ecuaciones geodésicas en 2 ecuaciones diferenciales de segundo orden que obtuvimos en la ecuación 2.28 igualando la curvatura geodésica kg a 0 <a  href="#$18" title="[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.">[18]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a>:</p>
    <img src="assets/images/image024.png" alt="">
    <p>Donde u’, u’’, v’ y v’’ son las derivadas de primer y segundo orden de u y v. El sistema anterior de dos ecuaciones diferenciales de segundo orden se puede expresar como un sistema de cuatro ecuaciones diferenciales de primer orden para ayudar a resolverlas:</p>
    <img src="assets/images/image025.png" alt="">
  </section>
  <section id="cap3">
    <h1>Capítulo 3: Creación de recorridos.</h1>
    <h2>3.1 Caminos geodésicos</h2>
    <h3>3.1.1 Cilindros</h3>
    <p>Como se dijo antes, las trayectorias geodésicas a lo largo de un cilindro describen la forma de una hélice. Si se abre la superficie de un cilindro, se puede ver que la hélice describe una línea recta y es fácil ver el ángulo α que forma la curva con la dirección meridional <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>:</p>
    <img src="assets/images/image026.png" alt="">
    <figura>Figura 3.1: Geodésica sobre un cilindro <a  href="#$2" title="[2] http://www.jp-petit.org/science/ingephn\_f/Dessins/a011.gif.">[2]</a></figura>
    <img src="assets/images/image027.png" alt="">
    <figura>Figura 3.2: α con respecto a las coordenadas meridionales y paralelas <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a></figura>
    <p>Una hélice se puede parametrizar fácilmente de la siguiente manera:</p>
    <img src="assets/images/image028.png" alt="">
    <p>Donde ρ es el radio del cilindro, ϕ es el parámetro angular y C es una constante.</p>
    <p>Como podemos ver en las figuras 3.1 y 3.2 y en la parametrización de la ecuación 3.1:</p>
    <img src="assets/images/image029.png" alt="">
    <p>O:</p>
    <img src="assets/images/image030.png" alt="">
    <h3>3.1.2 Conos</h3>
    <p>La descripción de una geodésica a lo largo de una superficie cónica está bien definida por la llamada relación de Clairaut <a  href="#$8" title="[8] Hugo Faria. Analytical and numerical modelling of the filament winding process. 2007.">[8]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$12" title="[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.">[12]</a><a  href="#$11" title="[11] B S Johansen, Aa Lystrup, and M T Jensen. CADPATH: A complete program for the CAD-, CAE- and CAM-winding of advanced fibre composites. Journal of Materials Processing Technology, 300(3-4):194-200, 1998.">[11]</a>:</p>
    <img src="assets/images/image031.png" alt="">
    <p>Donde ρ es el radio en una sección específica del cono, α es el ángulo que forma la curva con la dirección meridional del cono (su generatriz) en esa sección específica y C1 es una constante.</p>
    <p>En el caso del cono también es fácil ver que si se abre una superficie cónica, la geodésica describirá una línea recta:</p>
    <img src="assets/images/image032.png" alt="">
    <figura>Figura 3.3: Geodésica sobre un cono <a  href="#$2" title="[2] http://www.jp-petit.org/science/ingephn\_f/Dessins/a011.gif.">[2]</a></figura>
    <p>La trayectoria geodésica en un cono se puede describir sólo con el ángulo φ y el radio ρ. El ángulo se puede describir en función del radio <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>:</p>
    <img src="assets/images/image033.png" alt="">
    <p>Donde τ es el ángulo que forma una generatriz con el eje (o línea central) del cono y ρmax es el radio máximo del cono.</p>
    <img src="assets/images/image034.png" alt="">
    <figura>Figura 3.4: Carcasa cónica <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a></figura>
    <p>Ahora podemos parametrizar la curva:</p>
    <img src="assets/images/image035.png" alt="">
    <h3>3.1.3 Otras geometrías</h3>
    <p>Como se ha comentado anteriormente, esta tesis se centra en cilindros y conos. Sin embargo, para la mayoría de las aplicaciones de ingeniería, una superficie con eje simétrico se puede aproximar, con cualquier grado de precisión, mediante una serie de segmentos compuestos de conos y cilindros y, por lo tanto, es posible crear un camino geodésico sobre esa superficie. La convergencia del camino geodésico en la superficie real y en la superficie aproximada ha sido estudiada y probada por Gold <a  href="#$20" title="[20] S.P. Gold. Filament Winding Surface of Revolution, Technical Report SCLDR-65-105, Sandia Corporation, Livermore Laboratory, Livermore, California. 1966.">[20]</a>. Por lo tanto, es seguro calcular trayectorias geodésicas para una superficie aproximada y mantener su precisión y propiedades.</p>
    <h2>3.2 Caminos no geodésicos</h2>
    <p>Para definir correctamente un camino no geodésico sobre la superficie de un mandril, siempre debemos garantizar la estabilidad de la fibra. No debe haber deslizamiento entre la fibra y el mandril. Por tanto, debemos estudiar las fuerzas que actúan sobre la fibra y determinar los posibles caminos que puede tomar.</p>
    <img src="assets/images/image036.png" alt="">
    <figura>Figura 3.5: Fuerzas que actúan a lo largo de la trayectoria de una fibra <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a></figura>
    <p>La estabilidad de la fibra depende de que la fuerza lateral fb (debido al cambio del ángulo de la fibra) sea menor que la fuerza de fricción ff. Para un coeficiente de fricción estático µ, consideramos una fuerza de fricción de Coulomb donde <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a><a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a><a  href="#$21" title="[21] Cheol U. Kim, Ji H. Kang, Chang S. Hong, and Chun G. Kim. Optimal design of filament wound structures under internal pressure based on the semi-geodesic path algorithm. Composite Structures, 67(4):443-452, 2005.">[21]</a><a  href="#$22" title="[22] J. De Carvalho, M. Lossie, D. Vandepitte, and H. Van Brussel. Optimization of filament-wound parts based on non-geodesic winding. Composites Manufacturing, 6(2):79-84, 1995.">[22]</a>:</p>
    <img src="assets/images/image037.png" alt="">
    <p>Por lo tanto podemos concluir que:</p>
    <img src="assets/images/image038.png" alt="">
    <p>Considerando λ como un número de parámetro cuyo valor está entre −µ y µ, |λ| ≤ µ para garantizar la estabilidad de la fibra. La misma expresión que la ecuación 3.8 se puede expresar en términos de las curvaturas geodésica y normal<a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a><a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$21" title="[21] Cheol U. Kim, Ji H. Kang, Chang S. Hong, and Chun G. Kim. Optimal design of filament wound structures under internal pressure based on the semi-geodesic path algorithm. Composite Structures, 67(4):443-452, 2005.">[21]</a>:</p>
    <img src="assets/images/image039.png" alt="">
    <h3>3.2.1 Cilindros</h3>
    <p>Para describir la trayectoria en un cilindro no podremos utilizar coordenadas polares ya que z no se puede definir en función de ρ. Por lo tanto, se utilizarán coordenadas esféricas para describir su superficie y calcular la trayectoria<a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>.</p>
    <img src="assets/images/image040.png" alt="">
    <figura>Figura 3.6: Mandril cilíndrico</figura>
    <p>Los parámetros independientes utilizados para describir la superficie del cilindro y las trayectorias de las fibras serán φ que representa el ángulo a lo largo del eje z y es el parámetro paralelo y θ que representa el parámetro meridional <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a><a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a>:</p>
    <img src="assets/images/image041.png" alt="">
    <p>Ahora podemos calcular las formas fundamentales y las curvaturas meridionales y paralelas se pueden expresar en términos de los parámetros de la superficie<a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image042.png" alt="">
    <img src="assets/images/image043.png" alt="">
    <p>Los términos de la curvatura geodésica se simplifican enormemente ya que F = 0 y M = 0. Al resolver la ecuación 2.27 con las formas fundamentales recién calculadas, quedamos reducidos a <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image044.png" alt="">
    <p>Al sustituir los kg y kn recién calculados en la ecuación 3.9 llegamos a una ecuación diferencial ordinaria que describe α como una función de θ <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a><a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$23" title="[23] Jae Sung Park, Chang Sun Hong, Chun Gon Kim, and Cheol Ung Kim. Analysis of filament wound composite structures considering the change of winding angles through the thickness direction. Composite Structures, 55(1):63-71, 2002.">[23]</a>:</p>
    <img src="assets/images/image045.png" alt="">
    <p>Podemos describir completamente la curva expresando φ en función de α y θ. De manera similar, también podemos determinar la longitud del arco entre 2 puntos en función de α y θ como se ve a continuación <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a><a  href="#$15" title="[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.">[15]</a><a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a>:</p>
    <img src="assets/images/image046.png" alt="">
    <p>Ahora es posible aplicar una resolución numérica a las expresiones anteriores (3.15, 3.16 y 3.17). Para resolver la ecuación 3.15 se aplicó el método de Euler modificado <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image047.png" alt="">
    <p>Donde h es el paso y es igual a (θ(i+1)−θ(i)). Las ecuaciones (3.16 y 3.17) se resolvieron de manera similar como se puede ver a continuación <a  href="#$4" title="[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.">[4]</a>:</p>
    <img src="assets/images/image048.png" alt="">
    <p>Para mantener un incremento de longitud constante ds a lo largo del camino de la fibra, θi+1 se calculó de la siguiente manera:</p>
    <img src="assets/images/image049.png" alt="">
    <img src="assets/images/image050.png" alt="">
    <img src="assets/images/image051.png" alt="">
    <img src="assets/images/image052.png" alt="">
    <figura>Figura 3.7: Incrementos en la superficie del mandril</figura>
    <h3>3.2.2 Conos</h3>
    <p>Dado que las capas cónicas se pueden describir en coordenadas polares, se utilizarán éstas debido a su simplicidad. El método utilizado para resolver las trayectorias de los mandriles cónicos es idéntico al utilizado para los cilíndricos pero con un sistema de coordenadas diferente y, por tanto, diferentes parámetros:</p>
    <img src="assets/images/image053.png" alt="">
    <figura>Figura 3.8: Mandril cónico</figura>
    <p>Los parámetros independientes utilizados para describir la superficie del cono y las trayectorias de las fibras serán φ que representa el ángulo a lo largo del eje z y es el parámetro paralelo y ρ que representa el radio y es el parámetro meridional:</p>
    <img src="assets/images/image054.png" alt="">
    <p>Siguiendo la misma metodología que antes, llegamos a la ecuación diferencial ordinaria que describe α en función de ρ <a  href="#$3" title="[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.">[3]</a><a  href="#$23" title="[23] Jae Sung Park, Chang Sun Hong, Chun Gon Kim, and Cheol Ung Kim. Analysis of filament wound composite structures considering the change of winding angles through the thickness direction. Composite Structures, 55(1):63-71, 2002.">[23]</a>:</p>
    <img src="assets/images/image055.png" alt="">
    <p>También podemos describir la curva expresando φ en función de α y ρ y también determinar la longitud del arco entre dos puntos en función de α y ρ como se ve a continuación:</p>
    <img src="assets/images/image056.png" alt="">
    <p>Y la resolución numérica también sigue lo mostrado anteriormente como se puede ver a continuación:</p>
    <img src="assets/images/image057.png" alt="">
    <p>Donde h ahora es igual a (ρ(i + 1) − ρ(i)).</p>
    <img src="assets/images/image058.png" alt="">
    <p>De manera similar a lo que se hizo anteriormente, zi+1 y, en consecuencia, ρi+1 se calcularon de una manera que mantiene el incremento en la longitud del arco ds aproximadamente constante:</p>
    <img src="assets/images/image059.png" alt="">
    <h2>3.3 Zonas de retorno</h2>
    <p>El área de giro en un tubo o cono de bobinado de filamentos es el área donde la fibra comienza a cambiar el ángulo de bobinado para regresar a donde había pasado antes en un ángulo α pero ahora pasa en un ángulo π − α.</p>
    <img src="assets/images/image060.png" alt="">
    <figura>Figura 3.9: Giro de una fibra sobre la superficie de un mandril</figura>
    <p>Esto se logra fijando un valor al parámetro λ y definiendo el recorrido de la fibra hasta alcanzar un ángulo de enrollamiento α de π=2 (condición de frontera donde la fibra cambia de dirección de progresión a lo largo de su eje de revolución). A partir de ahí, el devanado puede permanecer en el mismo paralelo del mandril y seguir devanándose a un α de π=2 si así se desea. Para continuar girando, el camino hace el cambio simétrico que se hizo antes hasta que el ángulo alcanza π − α.</p>
    <h2>3.4 Generación de patrones</h2>
    <p>Los patrones de bobinado son los patrones formados por la fibra que va y viene a lo largo de un mandril y se cruza y se superpone en ciertos puntos.</p>
    <p>Un concepto importante a tener en cuenta es la cantidad de ciclos para un ancho de banda b y un ángulo α determinados necesarios para cubrir completamente el mandril:</p>
    <img src="assets/images/image061.png" alt="">
    <p>Para que dos ciclos consecutivos se coloquen de forma continua en el lugar correcto, debe existir un ángulo ∆φ entre el inicio y el final de un ciclo. Para lograr el ángulo ∆φ correcto y al mismo tiempo mantener la forma general del cable en el mandril, es posible simplemente dejar que la fibra permanezca en el medio de la vuelta cuando α = π=2 para un cierto ángulo de ∆φdwell. . Para los cilindros, este ∆φdwell se divide en partes iguales entre ambas vueltas mientras que para los conos se divide proporcionalmente a los perímetros de donde se están produciendo las permanencias. Para que el ángulo ∆φ entre ciclos sea correcto se debe seguir una regla. Si ∆φn es el cambio angular que normalmente ocurriría en un ciclo sin interferencia externa y Ω = ∆φnmod(2π), entonces:</p>
    <img src="assets/images/image062.png" alt="">
    <p>Donde PN es el número de patrón y representa el número de ciclos que deben pasar antes de que el filamento se coloque al lado del primero, SI es el índice de salto y representa el número de ciclos que se salta el patrón. Esto se explica en los siguientes diagramas (Figura 3.10) donde PN = 5 y SI = 1 y SI = 2 respectivamente:</p>
    <img src="assets/images/image063.png" alt="">
    <figura>Figura 3.10: Número de patrón e índice de salto explicados <a  href="#$5" title="[5] CADWIND User manual - Process simulation for filament winding, Material S. A. 2007.">[5]</a>.</figura>
    <p>Este tipo de patrones sólo se pueden hacer si Nc/PN  ℕ, lo cual no siempre es cierto. Además, sólo funcionan si el giro se realiza por un camino no geodésico, aunque esto no siempre es necesario o deseado porque el giro se puede realizar de forma geodésica si hay una pequeña apertura polar como es el caso de la mayoría de los COPV.</p>
    <p>Johansen et al. presentaron un método numérico para determinar posibles patrones de bobinado para anchos de filamentos, ángulos de bobinado y geometrías de mandril específicos (que siempre cumplen con la condición Nc/PN  ℕ). <a  href="#$11" title="[11] B S Johansen, Aa Lystrup, and M T Jensen. CADPATH: A complete program for the CAD-, CAE- and CAM-winding of advanced fibre composites. Journal of Materials Processing Technology, 300(3-4):194-200, 1998.">[11]</a> y se implementó en A.3.</p>
  </section>
  <section id="cap4">
    <h1>Capítulo 4: Programación de máquinas</h1>
    <h2>4.1 Configuración de la máquina</h2>
    <p>La máquina Bobinadora de Filamento presente en las instalaciones del INEGI y en la que se centrará este estudio es, como se ha visto anteriormente, la Pultrex MODwind 1S 6NC. Se trata de una máquina con 6 ejes controlados numéricamente como su nombre indica. Los ejes que tiene disponibles la máquina son (como se puede observar en la Figura 4.1):</p>
    <ul>
      <li>Husillo o Mandril (Eje A);</li>
      <li>Carro (Eje X)</li>
      <li>Carro transversal (Eje Y)</li>
      <li>Rotación del ojo de pago o alimentación (Eje B)</li>
      <li>Eje vertical (Eje Z)</li>
      <li>Eje de guiñada (Eje C)</li>
    </ul>
    <img src="assets/images/image064.png" alt="">
    <figura>Figura 4.1: Movimientos de los ejes en el Pultrex MODwind 1S 6NC</figura>
    <p>Debido a su elevado número de ejes móviles, esta máquina es capaz de producir casi cualquier tipo de pieza. Sin embargo, el estudio de esta tesis se centra en piezas simétricas respecto a un eje y, en particular, en cilindros y conos, por lo que no se analizarán y utilizarán todos los ejes.</p>
    <p>Los cuatro ejes que se utilizarán son la rotación del husillo/mandril, el movimiento del carro, el movimiento del carro transversal y la rotación del ojo de avance/alimentación. Estos son suficientes para los fines previstos e incluso serían suficientes para piezas mucho más complejas <a  href="#$24" title="[24] W Polini and L Sorrentino. Influence of winding speed and winding trajectory on tension in robotized filament winding of full section parts. Composites Science and Technology, 65(10):1574-1581, 2005.">[24]</a>.</p>
    <h2>4.2 Movimientos de los ejes</h2>
    <p>Para estudiar el movimiento que requiere cada eje, fue necesario estudiar la posición que debe tener cada eje cuando se está colocando los filamentos sobre el mandril en un punto concreto. Al conocer la relación entre el punto en el mandril y la posición de los ejes, resulta fácil transformar las coordenadas de la trayectoria de filamento en movimientos de los ejes <a  href="#$25" title="[25] S. Koussios, O. K. Bergsma, and a. Beukers. Filament winding. Part 2: Generic kinematic model and its solutions. Composites Part A: Applied Science and Manufacturing, 35:197-212, 2004.">[25]</a><a  href="#$26" title="[26] S. Koussios, O.K. Bergsma, and a. Beukers. Filament winding: kinematics, collision control and process optimisation through application of dynamic programming. Composites Part A: Applied Science and Manufacturing, 37:2088-2104, 2006.">[26]</a><a  href="#$24" title="[24] W Polini and L Sorrentino. Influence of winding speed and winding trajectory on tension in robotized filament winding of full section parts. Composites Science and Technology, 65(10):1574-1581, 2005.">[24]</a><a  href="#$13" title="[13] Johan Scholliers and Hendrik Van Brussel. Computer-integrated filament winding: computer-integrated design, robotic filament winding and robotic quality control. Composites Manufacturing, 5(1):15-23, 1994.">[13]</a>.</p>
    <img src="assets/images/image065.png" alt="">
    <figura>Figura 4.2: Mandril y ojo de alimentación 1.</figura>
    <img src="assets/images/image066.png" alt="">
    <figura>Figura 4.3: Mandril y ojo de alimentación 2.</figura>
    <img src="assets/images/image067.png" alt="">
    <figura>Figura 4.4: Mandril y ojo de alimentación 3.</figura>
    <img src="assets/images/image068.png" alt="">
    <figura>Figura 4.3: Mandril y ojo de alimentación 4.</figura>
    <p>Como se puede ver en la figura 4.4, ahora podemos expresar α en función de X e Y:</p>
    <img src="assets/images/image069.png" alt="">
    <p>Donde Y Ref es el radio de guiñada e Y y X representan la distancia entre la línea central del mandril donde se coloca el filamento y el ojo de alimentación.</p>
    <p>De la figura 4.3 podemos determinar la distancia e en función de distancias y ángulos conocidos:</p>
    <img src="assets/images/image070.png" alt="">
    <p>Donde ρ es el radio del mandril en el lugar de deposición y β es el ángulo que forma el cable con la horizontal al salir del ojo de alimentación.</p>
    <img src="assets/images/image071.png" alt="">
    <p>Ahora es posible determinar el ángulo B1:</p>
    <img src="assets/images/image072.png" alt="">
    <p>Y es posible determinar B con relación a B1:</p>
    <img src="assets/images/image073.png" alt="">
    <p>Al fijar la distancia Y, ahora es posible tener una descripción geométrica de cómo deben moverse tres ejes diferentes en relación con la trayectoria del mandril (que está determinada por el movimiento del cuarto eje, la rotación del husillo): el carro movimiento X, el movimiento del carro transversal Y y la rotación de alimentación B. Este es un enfoque simple de cómo deben moverse los ejes. De esta manera, el movimiento del carro transversal existe únicamente para mantener una cierta distancia a la superficie del mandril. Si se utilizan mandriles más complejos se deberán utilizar más ejes y de diferentes formas.</p>
    <h2>4.3 Parámetros de la máquina</h2>
    <p>En este apartado se mostrarán los datos referentes a las limitaciones físicas de la Máquina Bobinadora de Filamento Pultrex MODwind 1S 6NC. Estas restricciones se utilizaron para generar el código CNC, que luego fue leído por la máquina, para evitar cualquier tipo de mal funcionamiento.</p>
    <p>Estos datos fueron proporcionados por el INEGI y se obtuvieron mediante mediciones cuidadosas y datos de máquinas conocidas. Estos son los valores utilizados al emplear software externo para programar la máquina.</p>
    <h3>4.3.1 Dimensiones</h3>
    <p>Rango del carro (a lo largo del eje X medido desde la carcasa del husillo): 165,15 mm a 2644,7 mm.</p>
    <p>Rango del carro transversal (a lo largo del eje Y medido desde la cara delantera del carro): -120 mm a 311 mm.</p>
    <p>Rango del eje vertical (eje Z medido desde el eje del husillo): 0 mm a 364 mm.</p>
    <p>Ancho del ojo de alimentación: 50 mm.</p>
    <p>Radio de guiñada (medido desde el eje de guiñada C hasta la punta del ojo de alimentación): 260 mm.</p>
    <h3>4.3.2 Resoluciones</h3>
    <p>Mandril (eje A): 360 incrementos/revolución.</p>
    <p>Carro (eje X): 1 incremento/mm.</p>
    <p>Carro transversal (eje Y): 1 incremento/mm.</p>
    <p>Rotación de pago (eje B): 360 incrementos/revolución.</p>
    <p>Eje vertical (eje Z): 1 incremento/mm.</p>
    <p>Eje de guiñada (eje C): 360 incrementos/revolución.</p>
    <h3>4.3.3 Velocidades máximas</h3>
    <p>Mandril (eje A): 150 revoluciones/minuto.</p>
    <p>Carro (eje X): 1 m/s.</p>
    <p>Carro transversal (eje Y): 0,5 m/s.</p>
    <p>Rotación de pago (eje B): 115 revoluciones/minuto.</p>
    <p>Eje vertical (eje Z): 0,5 m/s.</p>
    <p>Eje de guiñada (eje C): 100 revoluciones/minuto.</p>
    <h3>4.3.4 Aceleraciones máximas</h3>
    <p>Las aceleraciones se definen en este contexto como la variación de velocidad máxima permitida de un eje entre dos juegos de datos de control.</p>
    <p>Mandril (eje A): 8 revoluciones/minuto.</p>
    <p>Carro (eje X): 4 m/s.</p>
    <p>Carro transversal (eje Y): 30 m/s.</p>
    <p>Rotación de pago (eje B): 60 revoluciones/minuto.</p>
    <p>Eje vertical (eje Z): 1 m/s.</p>
    <p>Eje de guiñada (eje C): 45 revoluciones/minuto.</p>
    <h2>4.4 Generación automática de código CNC</h2>
    <p>El controlador Sinumerik que se utiliza con la máquina requiere dos archivos diferentes. Un archivo de programa principal (*.mpf) y un archivo de subprograma (.spf). El archivo de subprograma es una subrutina dentro del archivo de programa principal que tiene las líneas de comando para ordenar a la máquina que se mueva de manera que el filamento complete un ciclo completo alrededor del mandril. El archivo de programa principal tiene que iniciar la máquina, colocar cada pieza de la máquina en la posición inicial (inicio del ciclo) y llamar al SPF el número correcto de veces (Nc) para producir una pieza.</p>
    <p>La velocidad de avance de cada línea de comando se calculó en función del tiempo y movimiento total de los ejes <a  href="#$5" title="[5] CADWIND User manual - Process simulation for filament winding, Material S. A. 2007.">[5]</a>:</p>
    <img src="assets/images/image074.png" alt="">
    <p>Donde An es el movimiento (cantidad de incrementos) en el eje enésimo y t es el tiempo en segundos que tarda en realizarse la línea de comando.</p>
    <p>El movimiento en cada eje se calcula como la diferencia de incrementos en la dirección de este eje entre dos puntos consecutivos en la trayectoria.</p>
    <p>El tiempo que se utiliza para calcular la velocidad de avance en cada línea de comando es el máximo de los tiempos que cada eje tarda en mover los incrementos asignados a su velocidad máxima. De esta forma conseguimos que la máquina se desplace a su máxima velocidad manteniendo la trayectoria correcta y sin sobrepasar sus limitaciones de velocidad.</p>
    <p>A continuación se muestra un ejemplo de una línea de código CNC (parte del archivo de subprograma) que fue desarrollado por el código Pathwind y probado y validado como se ve en el Capítulo 6.2:</p>
    <img src="assets/images/image075.png" alt="">
    <p>N04640 es la línea de comando, A1.675 es el movimiento incremental en el eje A (rotación en grados para el eje A), X-0.164 es el movimiento incremental en el eje X (traslación en mm para el eje X), Y0.000 es el movimiento incremental movimiento en el eje Y (traslación en mm para el eje Y), B-0.301 es el movimiento incremental en el eje B (rotación en grados para el eje B) y F36746.837 es el avance que se calculó como se muestra en la expresión 4.6.</p>
  </section>
  <section id="cap5">
    <h1>Capítulo 5: Modelado de la ruta de filamento real</h1>
    <p>El camino que sigue un cable de fibra después de enrollarse alrededor de un mandril no puede describirse simplemente por sus caminos a lo largo de la superficie. Hay subidas, bajadas, aprietes y liberaciones en los tramos donde hay superposición de fibras. Este rizado de la fibra puede crear tensiones residuales y debe estudiarse. Es por eso que uno de los objetivos del código presentado fue intentar modelar la realidad del camino de siga.</p>
    <h2>5.1 Sección transversal del filamento</h2>
    <p>A lo largo de los años se han presentado muchas secciones transversales de cable diferentes como una representación de cómo debería ser realmente el cable antes o después de aplicar tensión. Estos estudios se han realizado principalmente para elementos de volumen representativos (RVE) de tejidos o para técnicas de colocación avanzada de fibras (AFP), pero aplicaré sus estudios a nuestro caso de bobinado de filamentos <a  href="#$6" title="[6] Mahmood Ansar, Wang Xinwei, and Zhou Chouwei. Modeling strategies of 3D woven composites: A review. Composite Structures, 93(8):1947-1963, 2011.">[6]</a><a  href="#$7" title="[7] P. Potluri and a. Manan. Mechanics of non-orthogonally interlaced textile composites. Composites Part A: Applied Science and Manufacturing, 38(4):1216-1226, 2007.">[7]</a><a  href="#$27" title="[27] N. Vernet and F. Trochu. Analysis and modeling of 3D Interlock fabric compaction behavior. Composites Part A: Applied Science and Manufacturing,80:182-193, 2016.">[27]</a><a  href="#$28" title="[28] Byung Chul Kim, Paul M. Weaver, and Kevin Potter. Computer Aided Modelling of Variable Angle Tow Composites Manufactured by Continuous Tow Shearing. Composite Structures, 129:256-267, 2015.">[28]</a>.</p>
    <p>Las secciones transversales propuestas que se deben aplicar al devanado de filamentos para su estudio son las siguientes:</p>
    <img src="assets/images/image076.png" alt="">
    <figura>Figura 5.1: Formas de la sección transversal del filamento; (a) Elipsoidal, (b) Lenticular, (c) Rectangular, (d) Circular, (e) Pista de carreras y (f) Elemento de filamento. <a  href="#$6" title="[6] Mahmood Ansar, Wang Xinwei, and Zhou Chouwei. Modeling strategies of 3D woven composites: A review. Composite Structures, 93(8):1947-1963, 2011.">[6]</a></figura>
    <img src="assets/images/image077.png" alt="">
    <figura>Figura 5.2: Formas de la sección transversal del filamento; (a) Semielipsoidal, (b) Semilenticular, (c) Rectangular, (d) Semicircular, (e) Semipista y (f) Elemento de filamento. <a  href="#$6" title="[6] Mahmood Ansar, Wang Xinwei, and Zhou Chouwei. Modeling strategies of 3D woven composites: A review. Composite Structures, 93(8):1947-1963, 2011.">[6]</a></figura>
    <p>Estas secciones transversales pueden representar el filamento a lo largo de todo su recorrido o una variación de las secciones transversales dependiendo de la posición, la tensión y otras influencias externas pueden ocurrir a lo largo del recorrido del filamento. Cuando se aplica tensión a un cable que está sobre la superficie del mandril, una sección transversal semilenticular o semielipsoidal podría ser la más apropiada, por ejemplo. Es necesario realizar estudios futuros para determinar la mejor sección transversal a aplicar según la situación. Por ahora, el código Pathwind MatlabTM presentado solo es capaz de hacer secciones transversales rectangulares o semielipsoidales y mantener la sección transversal en todo su recorrido.</p>
    <img src="assets/images/image078.png" alt="">
    <figura>Figura 5.3: Sección transversal del filamento de Pathwind</figura>
    <h3>5.1.1 Sección transversal elipsoidal</h3>
    <img src="assets/images/image079.png" alt="">
    <figura>Figura 5.4: Sección transversal de filamento elipsoidal.</figura>
    <p>Es posible definir el borde del cable (coordenadas x e y) en función del ancho y espesor del cable:</p>
    <img src="assets/images/image080.png" alt="">
    <p>Donde t y es el espesor del cable, b es el ancho del cable, a1 y b1 son los ejes mayor y menor de la elipse respectivamente. β es el ángulo entre el semieje x positivo y la dirección de un punto P en el borde de la elipse.</p>
    <h3>5.1.2 Sección transversal lenticular</h3>
    <img src="assets/images/image081.png" alt="">
    <figura>Figura 5.5: Sección transversal del cable lenticular. <a  href="#$7" title="[7] P. Potluri and a. Manan. Mechanics of non-orthogonally interlaced textile composites. Composites Part A: Applied Science and Manufacturing, 38(4):1216-1226, 2007.">[7]</a></figura>
    <p>Es posible definir el borde del cable en función del ancho y espesor del cable:</p>
    <img src="assets/images/image082.png" alt="">
    <p>Donde t y es el espesor del cable, b es el ancho del cable, R1 es el radio de curvatura, A es el área de la sección transversal y γ es el ángulo representado.</p>
    <h3>5.1.3 Sección transversal redonda</h3>
    <img src="assets/images/image083.png" alt="">
    <figura>Figura 5.6: Sección transversal de filamento redondo.</figura>
    <p>Es posible definir el borde del filamento (coordenadas x e y) en función del radio del filamento:</p>
    <img src="assets/images/image084.png" alt="">
    <p>Donde t y es el espesor del cable, b es el ancho del cable y R1 es el radio. β es el ángulo entre el semieje x positivo y la dirección de un punto P en el borde del círculo.</p>
    <h3>5.1.4 Sección transversal de la pista de carreras</h3>
    <img src="assets/images/image085.png" alt="">
    <figura>Figura 5.7: Sección transversal del filamento del hipódromo.</figura>
    <p>La sección transversal de la pista de carreras se puede representar mediante 2 semicírculos en ambos extremos del rectángulo. Como ya se han mostrado las propiedades del círculo y la forma del rectángulo es bien conocida, se cree que esta forma ya está suficientemente definida.</p>
    <h2>5.2 Superposición de fibras</h2>
    <p>Para proporcionar un marco preciso en el que calcular y representar la ruta de filamento, se representa como una colección de rutas. Este conjunto de caminos está unido y forma una sección transversal cohesiva y sigue el camino tal como se definió anteriormente.</p>
    <img src="assets/images/image086.png" alt="">
    <figura>Figura 5.8: Sección transversal del filamento como una colección de caminos</figura>
    <p>La superposición se puede realizar entonces siempre que el cable encuentre otra parte de sí mismo. Por lo tanto, el cable está siempre en contacto con el mandril o con una sección anterior del mismo. Siempre que un camino en el filamento encuentre una sección anterior del filamento, el siguiente punto en su camino tendrá ρ = ρmandril + ty = cos τ y z = zmandril + ty sin τ. Entonces, si mientras está encima del cable se encuentra con otra parte más del cable, entonces ρ = ρmandril + 2ty = cos τ y z = zmandril + 2ty sin τ.</p>
    <img src="assets/images/image087.png" alt="">
    <figura>Figura 5.9: Representación del solapamiento del filamento</figura>
    <p>Este es el principio básico de cómo el código aborda la superposición de fibras y, si bien sigue siendo un enfoque simplista, es el comienzo de un proceso que aún debe perfeccionarse.</p>
    <p>En el apéndice A.1, se puede ver que la última sección del código Pathwind está dedicada únicamente a este método de realizar la superposición de fibras.</p>
  </section>
  <section id="cap6">
    <h1>Capítulo 6: Resultados y Discusión</h1>
    <p>En este capítulo se presentan cuatro pruebas virtuales (con diferentes características y parámetros de entrada) y la validación experimental de una de estas pruebas (Prueba 1). Las pruebas virtuales son simulaciones realizadas utilizando el código Pathwind y los resultados presentados son todos los resultados relevantes de este código.</p>
    <p>Todos los parámetros de entrada son especificaciones de diseño realizadas por el ingeniero de procesos o por el operador de la máquina y las salidas son la base para el código CNC que se generará para controlar los ejes de la máquina.</p>
    <p>Las pruebas que se muestran en este capítulo fueron elegidas deliberadamente ya que todas tienen parámetros de entrada razonables que pueden aplicarse en la máquina bobinadora de filamentos del INEGI. El INEGI produce regularmente piezas similares, por lo que estas pruebas se consideraron interesantes para referencia futura. De las cuatro pruebas, la Prueba 1 y la Prueba 3 tienen mandriles cilíndricos, mientras que la Prueba 2 y la Prueba 4 tienen mandriles cónicos.</p>
    <h2>6.1 Pruebas virtuales</h2>
    <p>En todas las pruebas presentadas aquí, se eligió un parámetro λ de 0,14 ya que es un valor generalmente aceptado para el bobinado de fibra húmeda y seca <a  href="#$5" title="[5] CADWIND User manual - Process simulation for filament winding, Material S. A. 2007.">[5]</a> sobre un mandril metálico. El proceso utilizado en el INEGI es el devanado húmedo por lo que permite validar los resultados.</p>
    <h3>6.1.1 Prueba 1 - Mandril cilíndrico</h3>
    <p>En esta prueba, se prueban las limitaciones físicas del devanado de filamentos con parámetros de devanado típicos en un mandril cilíndrico existente.</p>
    <p>Parámetros de entrada:</p>
    <p>Ancho de filamento: b=6mm</p>
    <p>Radio del mandril: r=75mm</p>
    <p>Coordenada del extremo izquierdo del mandril: zim=-500mm</p>
    <p>Coordenada del extremo izquierdo del área de bobinado geodésico: zi=0mm</p>
    <p>Coordenada del extremo derecho del área de bobinado geodésico: zfg=300mm</p>
    <p>Coordenada del extremo derecho del mandril: zfm=1000mm</p>
    <p>Ángulo de bobinado: α=45º</p>
    <p>Parámetro λ: λ=0,14</p>
    <p>Para estos parámetros de entrada, se obtuvieron los siguientes resultados:</p>
    <p>zmín=-222,99 mm</p>
    <p>zmáx=522,99mm</p>
    <p>Longitud de la pieza = 745,98 mm</p>
    <p>Nc=56</p>
    <p>Ciclo Lf=3322,7 mm</p>
    <p>Lf-total=186,17m</p>
    <img src="assets/images/image088.png" alt="">
    <figura>Figura 6.1: Variación de parámetros a lo largo de un ciclo</figura>
    <p>Las variaciones de los parámetros indicados en la figura 6.1 son acordes a lo esperado del bobinado de una pieza cilíndrica. α varía entre su valor inicial αi y π − αi, invirtiéndose cuando es igual a π=2 como es de esperar. Tanto φ como Lf siguen aumentando de la manera esperada a lo largo de un ciclo.</p>
    <img src="assets/images/image089.png" alt="">
    <figura>Figura 6.2: Trayectoria de filamento a lo largo de un ciclo</figura>
    <p>En la figura 6.2 se muestra el primer ciclo finalizando justo al lado de donde comenzó, permitiendo de esta manera cubrir completamente el mandril.</p>
    <img src="assets/images/image090.png" alt="">
    <figura>Figura 6.3: Caminos de filamento a lo largo del mandril para todos los ciclos en una capa</figura>
    <p>Se puede observar en la figura 6.3 que los 56 ciclos cubren la superficie del mandril en un patrón uniforme.</p>
    <img src="assets/images/image091.png" alt="">
    <figura>Figura 6.4: Movimientos de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Los movimientos de los ejes de la máquina mostrados en la figura 6.4 son acordes a lo esperable y fue presentado en el capítulo 4 para el bobinado de una pieza cilíndrica.</p>
    <img src="assets/images/image092.png" alt="">
    <figura>Figura 6.5: Velocidades de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Parece que hay algunas inconsistencias puntuales en las velocidades de los ejes A y X. Queda por determinar si estas inconsistencias se deben únicamente a la determinación de la velocidad calculada para los gráficos o si realmente se tradujeron al código CNC y al control de la máquina. Hubo algunas aceleraciones agresivas en la producción de la pieza, como se analiza en el Capítulo 6.2, y podrían deberse a estas inconsistencias.</p>
    <img src="assets/images/image093.png" alt="">
    <figura>Figura 6.6: Pieza completamente enrollada con traslape de filamento</figura>
    <img src="assets/images/image094.png" alt="">
    <figura>Figura 6.7: Pieza completamente enrollada con traslape de filamento en detalle</figura>
    <p>La superposición de fibras realizada por el código Pathwind parece mostrar algunas irregularidades en el área de permanencia de los giros. Probablemente se deba al hecho de que la rotación de permanencia, el espesor del filamento y el número de ciclos fueron todos altos.</p>
    <h3>6.1.2 Prueba 2 - Mandril cónico</h3>
    <p>En esta prueba, las limitaciones físicas del devanado de filamentos con parámetros de devanado típicos se prueban en un mandril cónico.</p>
    <p>Parámetros de entrada:</p>
    <p>Ancho de filamento: b=5mm</p>
    <p>Radio del mandril en el extremo izquierdo: borde = 30 mm</p>
    <p>Radio del mandril en el extremo derecho: rfm=50mm</p>
    <p>Coordenada del extremo izquierdo del mandril: zim=0mm</p>
    <p>Coordenada del extremo izquierdo del área de bobinado geodésico: zi=100 mm</p>
    <p>Coordenada del extremo derecho del área de bobinado geodésico: zfg=300mm</p>
    <p>Coordenada del extremo derecho del mandril: zfm=600mm</p>
    <p>Ángulo de bobinado: α=75o</p>
    <p>Parámetro λ: λ=0,14</p>
    <p>Para estos parámetros de entrada, se obtuvieron los siguientes resultados:</p>
    <p>zmín=88,7 mm</p>
    <p>zmáx=399,1 mm</p>
    <p>Longitud de la pieza = 310,4 mm</p>
    <p>Nc=30</p>
    <p>Ciclo Lf=1766,3 mm</p>
    <p>Lf-total=52,99m</p>
    <img src="assets/images/image095.png" alt="">
    <figura>Figura 6.8: Variación de parámetros a lo largo de un ciclo</figura>
    <p>La variación de parámetros indicada en la figura 6.8 es acorde a lo que se espera del bobinado de una pieza cónica. α varía entre su valor inicial αi y disminuye a medida que aumenta el radio hasta llegar al área de giro y comienza a aumentar hasta llegar a π=2 como es de esperar. Tanto φ como Lf siguen aumentando de la manera esperada a lo largo de un ciclo.</p>
    <img src="assets/images/image096.png" alt="">
    <figura>Figura 6.9: Trayectoria de filamento a lo largo de un ciclo.</figura>
    <p>La Figura 6.9 muestra el primer ciclo finalizando justo al lado de donde comenzó, permitiendo de esta manera cubrir completamente el mandril.</p>
    <img src="assets/images/image097.png" alt="">
    <figura>Figura 6.10: Caminos de filamento a lo largo del mandril para todos los ciclos en una capa</figura>
    <p>Se puede observar en la figura 6.10 que los 30 ciclos cubren la superficie del mandril en un patrón uniforme.</p>
    <img src="assets/images/image098.png" alt="">
    <figura>Figura 6.11: Movimientos de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Los movimientos de los ejes de la máquina para los ejes A, B y X mostrados en la figura 6.11 son acordes a lo esperado para el bobinado de una pieza cónica. Sin embargo, el movimiento del eje Y tiene algunas irregularidades a lo largo del ciclo y aunque las irregularidades son de pequeño valor, pueden alterar el recorrido deseado de la fibra en el mandril. Creo que la razón de estos aumentos y disminuciones en el eje Y está relacionada con la forma numérica en que se calcula la distancia Y (incrementalmente hasta alcanzar la distancia fija al mandril).</p>
    <img src="assets/images/image099.png" alt="">
    <figura>Figura 6.12: Velocidades de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Ahora parece que hay muchas inconsistencias en las velocidades de todos los ejes. Queda por determinar si estas inconsistencias se deben únicamente a la determinación de la velocidad calculada para los gráficos o si realmente se tradujeron al código CNC y al control de la máquina.</p>
    <img src="assets/images/image100.png" alt="">
    <figura>Figura 6.13: Pieza completamente enrollada con traslape de filamento</figura>
    <p>Las irregularidades en la superposición de fibras que se observan en la Prueba 1 también están presentes en esta prueba y probablemente se deban a las mismas causas. También se observan algunos aumentos de espesor en todos los tramos donde hay cruces de fibras y probablemente también se deban a las mismas causas.</p>
    <h3>6.1.3 Prueba 3 - Mandril cilíndrico</h3>
    <p>En esta prueba, las limitaciones físicas del devanado de filamentos con parámetros de devanado típicos se prueban en un mandril cilíndrico.</p>
    <p>Parámetros de entrada:</p>
    <p>Ancho de filamento: b=10mm</p>
    <p>Radio del mandril: r=15mm</p>
    <p>Coordenada del extremo izquierdo del mandril: zim=-500mm</p>
    <p>Coordenada del extremo izquierdo del área de bobinado geodésico: zi=0mm</p>
    <p>Coordenada del extremo derecho del área de bobinado geodésico: zfg=300mm</p>
    <p>Coordenada del extremo derecho del mandril: zfm=1000mm</p>
    <p>Ángulo de bobinado: α=20o</p>
    <p>Parámetro λ: λ=0,14</p>
    <p>Para estos parámetros de entrada, se obtuvieron los siguientes resultados:</p>
    <p>zmín=-208,77 mm</p>
    <p>zmáx=508,77 mm</p>
    <p>Longitud de la pieza = 717,54 mm</p>
    <p>Nc=9</p>
    <p>Ciclo Lf=1884,5 mm</p>
    <p>Lf-total=16,96m</p>
    <img src="assets/images/image101.png" alt="">
    <figura>Figura 6.14: Variación de parámetros a lo largo de un ciclo</figura>
    <p>Como se vio en el Ensayo 1, las variaciones de los parámetros indicados en la figura 6.14 son acordes a lo esperado del bobinado de una pieza cilíndrica y presentan las mismas características que el Ensayo 1.</p>
    <img src="assets/images/image102.png" alt="">
    <figura>Figura 6.15: Trayectoria de filamento a lo largo de un ciclo</figura>
    <p>Como se vio anteriormente en el Ensayo 1 y Ensayo 2, en la figura 6.15 se muestra el primer ciclo finalizando justo al lado de donde comenzó, permitiendo de esta manera cubrir completamente el mandril.</p>
    <img src="assets/images/image103.png" alt="">
    <figura>Figura 6.16: Caminos de filamento a lo largo del mandril para todos los ciclos en una capa</figura>
    <p>Se puede observar en la figura 6.16 que los 9 ciclos cubren la superficie del mandril en un patrón uniforme.</p>
    <img src="assets/images/image104.png" alt="">
    <figura>Figura 6.17: Movimientos de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Los movimientos de los ejes de la máquina mostrados en la figura 6.17 son acordes a lo que se espera del bobinado de una pieza cilíndrica y tienen los mismos movimientos generales que los del Ensayo 1 (el movimiento de los ejes para todos los cilindros es similar).</p>
    <img src="assets/images/image105.png" alt="">
    <figura>Figura 6.18: Velocidades de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Parece que existen algunas inconsistencias puntuales en las velocidades de los ejes A, B y X. Las inconsistencias en esta prueba son más pronunciadas de lo visto anteriormente y muestran algunos saltos en las velocidades de esos tres ejes. Queda por determinar si estas inconsistencias se deben únicamente a la determinación de la velocidad calculada para los gráficos o si realmente se tradujeron al código CNC y al control de la máquina.</p>
    <img src="assets/images/image106.png" alt="">
    <figura>Figura 6.19: Pieza completamente enrollada con traslape de filamento</figura>
    <img src="assets/images/image107.png" alt="">
    <figura>Figura 6.20: Pieza completamente enrollada con traslape de filamento - detalle</figura>
    <p>El solapamiento de fibras visto en las figuras 6.19 y 6.20 parece representar la realidad mejor que las pruebas anteriores. El espesor parece ser correcto en todo el tubo y se observan claramente los solapamientos y cruces. Esto parece deberse al menor número de ciclos enrollados que producen superposiciones menos gruesas y más consistentes. Sin embargo, todavía aparecen algunas áreas onduladas en las áreas de giro.</p>
    <h3>6.1.4 Prueba 4 - Mandril cónico</h3>
    <p>En esta prueba, las limitaciones físicas del devanado de filamentos con parámetros de devanado típicos se prueban en un mandril cónico.</p>
    <p>Parámetros de entrada:</p>
    <p>Ancho de filamento: b=15mm</p>
    <p>Radio del mandril en el extremo izquierdo: borde = 15 mm</p>
    <p>Radio del mandril en el extremo derecho: rfm=60mm</p>
    <p>Coordenada del extremo izquierdo del mandril: zim=-500mm</p>
    <p>Coordenada del extremo izquierdo del área de bobinado geodésico: zi=0mm</p>
    <p>Coordenada del extremo derecho del área de bobinado geodésico: zfg=300mm</p>
    <p>Coordenada del extremo derecho del mandril: zfm=1500mm</p>
    <p>Ángulo de bobinado: α=25o</p>
    <p>Parámetro λ: λ=0,14</p>
    <p>Para estos parámetros de entrada, se obtuvieron los siguientes resultados:</p>
    <p>zmín=-307,3113 mm</p>
    <p>zmáx=1195,3 mm</p>
    <p>Longitud de la pieza = 1502,6226 mm</p>
    <p>Nc=14</p>
    <p>Ciclo Lf=4167,4 mm</p>
    <p>Lf-total=58343,6 mm=58,3436 m</p>
    <img src="assets/images/image108.png" alt="">
    <figura>Figura 6.21: Variación de parámetros a lo largo de un ciclo</figura>
    <p>La variación de parámetros indicada en la figura 6.21 es acorde a lo que se espera del bobinado de una pieza cónica y lo visto en el Ensayo 2. α varía entre su valor inicial αi y disminuye a medida que aumenta el radio hasta llegar al área de giro y inicia su largo aumento hasta alcanzar π=2 como es de esperar de este devanado debido a su bajo ángulo de enrollado. Tanto φ como Lf siguen aumentando de la manera esperada a lo largo de un ciclo.</p>
    <img src="assets/images/image109.png" alt="">
    <figura>Figura 6.22: Trayectoria de filamento a lo largo de un ciclo</figura>
    <p>La Figura 6.22 muestra el primer ciclo terminando justo al lado de donde comenzó, permitiendo de esta manera cubrir completamente el mandril.</p>
    <img src="assets/images/image110.png" alt="">
    <figura>Figura 6.23: Caminos de filamento a lo largo del mandril para todos los ciclos en una capa</figura>
    <p>Se puede observar en la figura 6.23 que los 14 ciclos cubren la superficie del mandril en un patrón uniforme.</p>
    <img src="assets/images/image111.png" alt="">
    <figura>Figura 6.24: Movimientos de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Los movimientos de los ejes de la máquina para los ejes A, B y X mostrados en la figura 6.24 son acordes a lo esperado para el bobinado de una pieza cónica y ya se vio en el Ensayo 2. Sin embargo, al igual que en el Ensayo 2, el movimiento del eje Y tiene algunas irregularidades a lo largo del ciclo probablemente debido a la misma causa.</p>
    <img src="assets/images/image112.png" alt="">
    <figura>Figura 6.25: Velocidades de los ejes de la máquina a lo largo de un ciclo</figura>
    <p>Las velocidades de todos los ejes vuelven a tener muchos picos e inconsistencias. Parece que el movimiento de los ejes de los mandriles cónicos tiene muchas inconsistencias.</p>
    <img src="assets/images/image113.png" alt="">
    <figura>Figura 6.26: Superposición de filamento con bobinado de un ciclo</figura>
    <img src="assets/images/image114.png" alt="">
    <figura>Figura 6.27: Pieza completamente enrollada con traslape de filamento</figura>
    <p>La superposición de fibras en esta prueba parece haber funcionado mejor que en otros casos, pero todavía hay algunas irregularidades de espesor en las áreas de giro.</p>
    <h2>6.2 Validación experimental</h2>
    <p>Como se dijo antes, la validación experimental se realizó con las mismas especificaciones que la Prueba virtual 1. La pieza se produjo utilizando el archivo de programa principal y el archivo de programa secundario (código CNC) que fueron una salida del código Pathwind MatlabTM.</p>
    <p>Parámetros de entrada:</p>
    <p>Ancho de filamento: b=6mm</p>
    <p>Radio del mandril: r=75mm</p>
    <p>Coordenada del extremo izquierdo del mandril: zim=-500mm</p>
    <p>Coordenada del extremo izquierdo del área de bobinado geodésico: zi=0mm</p>
    <p>Coordenada del extremo derecho del área de bobinado geodésico: zfg=300mm</p>
    <p>Coordenada del extremo derecho del mandril: zfm=1000mm</p>
    <p>Ángulo de bobinado: α=45o</p>
    <p>Parámetro λ: λ=0,14</p>
    <p>Para estos parámetros de entrada, se obtuvieron los siguientes resultados:</p>
    <p>zmín=-222,99 mm</p>
    <p>zmáx=522,99mm</p>
    <p>Longitud de la pieza = 745,98 mm</p>
    <p>Nc=56</p>
    <p>Ciclo Lf=3322,7 mm</p>
    <p>Lf-total=186,07m</p>
    <p>Para producir la pieza completa, el software determinó que para un ancho de filamento de 6 mm, eran necesarios 56 ciclos para cubrir completamente el mandril. Después de ejecutar el archivo de programa principal, la máquina se posicionó en la posición inicial y llamó al archivo de programa secundario 56 veces seguidas.</p>
    <p>En la producción de la pieza se utilizó bobinado de fibra seca. Esto significa que no se utilizó ninguna matriz plástica termoestable y, por lo tanto, la pieza no era permanente (tuvo que ser desenrollada una vez terminada).</p>
    <p>Durante el proceso en sí, los ejes de la máquina se movieron de acuerdo con lo esperado y normalmente sucede cuando se emplea otro software para crear el código CNC. Hubo aceleraciones agresivas en algunas zonas pero nada que no ocurra normalmente. Se debe realizar un estudio cuidadoso sobre la generación de la alimentación para limitar estos ataques de aceleración/desaceleración.</p>
    <img src="assets/images/image115.png" alt="">
    <figura>Figura 6.28: Proceso de bobinado en el área geodésica 6.28a y en el área de giro 6.28b</figura>
    <p>Durante el bobinado se puede observar un ligero espacio entre las fibras de dos caminos consecutivos en la figura 6.28a.</p>
    <img src="assets/images/image116.png" alt="">
    <figura>Figura 6.29: Pieza completamente enrollada</figura>
    <img src="assets/images/image117.png" alt="">
    <figura>Figura 6.30: Tamaño de la pieza producida 6.30a y de la sección geodésica 6.30b</figura>
    <p>En la figura 6.30a podemos observar que la longitud total de la pieza producida fue de 740 mm, lo que está muy cerca de los 745,98 mm previstos. La desviación de 5,98 mm probablemente se debe a un ligero deslizamiento de la fibra ya que la tensión del cable después del giro ejerce una fuerza en la dirección del centro de la pieza.</p>
    <p>En la figura 6.30b podemos observar que los 300 mm para el área geodésica parecen haber producido un devanado completamente geodésico.</p>
    <img src="assets/images/image118.png" alt="">
    <figura>Figura 6.31: Ancho del filamento 6.30a y medición del ángulo en el área de bobinado geodésico 6.30b</figura>
    <p>Es posible observar en la figura 6.31a que el ancho del filamento no era los 6 mm que se ingresaron en el código Pathwind. El ancho de filamento real fue de 5,15 mm y esta es la razón por la que podemos observar un ligero desfase entre los filamentos de ciclos consecutivos. A pesar de este ligero hueco, se obtuvo casi una cobertura total del mandril. Al observar la figura 6.29, podemos observar que el mandril no se puede ver fácilmente: la fibra lo cubre.</p>
    <p>De la figura 6.31b se puede observar que el ángulo de enrollamiento en el área geodésica de la pieza es exactamente de 45o en toda la zona geodésica como se solicitó. Esto significa que probablemente no hubo deslizamiento de fibra en el área geodésica de la pieza y si realmente hubo deslizamiento de fibra en el proceso, probablemente estuvo contenido en las áreas de giro.</p>
    <p>En general, la pieza producida fue muy similar a las especificaciones de diseño y el proceso en sí y los movimientos de los ejes se comportaron como se esperaba. Se requiere una validación experimental adicional, pero esta primera validación es suficiente para demostrar que los conceptos y modelos presentados a lo largo de la tesis e implementados en el código Pathwind son creíbles.</p>
  </section>
  <section id="cap7">
    <h1>Capítulo 7: Conclusión y trabajo futuro</h1>
    <h2>7.1 Conclusión</h2>
    <p>El principal objetivo de este trabajo fue estudiar, comprender y evaluar los diferentes tipos de trayectorias de fibras que se pueden realizar a lo largo de la superficie de un mandril axi-simétrico e implementarlas en una máquina bobinadora de filamentos real.</p>
    <p>Se presentaron modelos para describir trayectorias geodésicas a lo largo de superficies cilíndricas y cónicas. Estos modelos fueron implementados y validados exitosamente con pruebas virtuales y para el caso de los cilindros se validaron experimentalmente.</p>
    <p>La descripción de caminos no geodésicos que aún garantizan la estabilidad de la fibra también se presentó e implementó en el código Pathwind. La producción exitosa de una pieza enrollada con filamento con trayectorias no geodésicas y sin observación significativa de deslizamiento de la fibra indica que los modelos presentados funcionan. Sin embargo, aún se requiere más validación.</p>
    <p>Se propone e implementa un método para crear diferentes patrones de bobinado en cilindros y conos y el hecho de que las pruebas virtuales y la validación experimental muestren una cobertura completa del mandril parecen sugerir que el método funciona. Un método presentado por Johansen et al. <a  href="#$11" title="[11] B S Johansen, Aa Lystrup, and M T Jensen. CADPATH: A complete program for the CAD-, CAE- and CAM-winding of advanced fibre composites. Journal of Materials Processing Technology, 300(3-4):194-200, 1998.">[11]</a> que sirve para determinar qué patrones son posibles para diferentes parámetros de devanado también se analiza e implementa y se puede ver en A.3.</p>
    <p>Se realiza un estudio de los movimientos de los ejes de las máquinas bobinadoras de filamentos y se presenta un método de creación de código CNC que puede ser utilizado por la máquina presente en las instalaciones del INEGI. Luego se produce una pieza usando este código. El hecho de que la pieza producida tuviera la geometría solicitada indica que los movimientos de los ejes fueron precisos. Se observaron algunas aceleraciones y desaceleraciones agresivas y, aunque esto también se observa cuando se utilizan programas de control de máquinas de otros software CAD/CAM, es necesario realizar más estudios para mejorar el movimiento de los ejes y la velocidad de fabricación. También se observó en el capítulo 6 que parece haber muchas inconsistencias en la determinación de la velocidad de los diferentes ejes. Esto es especialmente evidente en la producción en mandriles cónicos.</p>
    <p>Se crean diferentes formas de describir el camino de filamento real a lo largo de una parte enrollada con filamento. Se presentan e implementan diferentes secciones transversales para el cable y una forma de describir la superposición de fibras. La superposición de fibras que se muestra como resultado del código Pathwind demostró inconsistencias como un espesor excesivo en algunas áreas y algunos altibajos que no deberían estar presentes. Es necesario realizar más estudios sobre las trayectorias reales de las fibras, ya que es importante comprender y modelar las tensiones causadas por la superposición de las fibras.</p>
    <p>En general, la generación automática de trayectorias de filamento en la superficie de un mandril para entradas de diseño específicas mediante el código Pathwind funciona bien. Se demostró que Pathwind es una herramienta que implementa los modelos presentados y ayudó a validarlos hasta cierto punto. Aún queda trabajo por hacer para mejorar y validar esta herramienta, pero se demostró que ya es posible producir diferentes piezas cilíndricas y cónicas utilizando el código Pathwind.</p>
    <h2>7.2 Trabajo futuro</h2>
    <p>El trabajo presentado a lo largo de este documento sirve como base para una herramienta de simulación de devanado de filamentos. Sin embargo, todavía queda mucho trabajo por hacer.</p>
    <p>En primer lugar, es necesario realizar la validación experimental de una multitud de piezas diferentes con diferentes parámetros geométricos y físicos. La validación experimental que se muestra en el Capítulo 6.2 sirve como prueba de concepto, pero no valida completamente los modelos presentados ni su potencial y límites físicos completos.</p>
    <p>El código Pathwind sirve como herramienta para producir piezas cilíndricas y cónicas, pero aún no alcanza las capacidades y aplicaciones del software CAD/CAM disponible. Por lo tanto, se sugiere que se realicen las siguientes mejoras y adiciones al código:</p>
    <ul>
      <li>permitir la entrada de diferentes geometrías de mandril, incluidas las no simétricas en el eje;</li>
      <li>producir una salida de malla FEA compatible y capaz de transferirse a plataformas FEA;</li>
      <li>crear una interfaz gráfica de usuario para que sea fácil de usar;</li>
      <li>producir una representación gráfica de la cinemática del proceso;</li>
      <li>mejorar el rendimiento de la máquina, la velocidad de fabricación y optimizar el movimiento de todos los ejes;</li>
      <li>Es necesario estudiar e implementar nuevos modelos para determinar las trayectorias y secciones transversales reales del filamento.</li>
    </ul>
    <p>Si las mejoras anteriores se realizan al código Pathwind y se validan experimentalmente, en mi opinión, el código sería igual en calidad al software de simulación de devanado de filamentos disponible actualmente. Por lo tanto, se garantizaría un control profundo de la cinemática del proceso y se mejorarían significativamente las capacidades del grupo de bobinado de filamento.</p>
  </section>
  <section id="bibliografia">
    <h1>Bibliografía</h1>
    <p id="$1">[1] Alting L. Todd RH, Allen DK. Fundamental Principles of Manufacturing Processes. New York: Industrial Press Inc. 1994.</p>
    <p id="$2">[2] http://www.jp-petit.org/science/ingephn\_f/Dessins/a011.gif.</p>
    <p id="$3">[3] Sotiris Koussios. Filament Winding: A Unified Approach. 2004.</p>
    <p id="$4">[4] E. Vargas Rojas, D. Chapelle, D. Perreux, B. Delobelle, and F. Thiebaud. Unified approach of filament winding applied to complex shape mandrels. Composite Structures, 116:805-813, 2014.</p>
    <p id="$5">[5] CADWIND User manual - Process simulation for filament winding, Material S. A. 2007.</p>
    <p id="$6">[6] Mahmood Ansar, Wang Xinwei, and Zhou Chouwei. Modeling strategies of 3D woven composites: A review. Composite Structures, 93(8):1947-1963, 2011.</p>
    <p id="$7">[7] P. Potluri and a. Manan. Mechanics of non-orthogonally interlaced textile composites. Composites Part A: Applied Science and Manufacturing, 38(4):1216-1226, 2007.</p>
    <p id="$8">[8] Hugo Faria. Analytical and numerical modelling of the filament winding process. 2007.</p>
    <p id="$9">[9] L Ainsworth. The state of fillament winding. (March), 1971.</p>
    <p id="$10">[10] Donald V. Rosato and Dominick V. Rosatot. Reinforced Plastics Handbook Third edition. page 1113, 2004.</p>
    <p id="$11">[11] B S Johansen, Aa Lystrup, and M T Jensen. CADPATH: A complete program for the CAD-, CAE- and CAM-winding of advanced fibre composites. Journal of Materials Processing Technology, 300(3-4):194-200, 1998.</p>
    <p id="$12">[12] Lei Zu. Design and Optimization of Filament Wound Composite Pressure Vessels. 2012.</p>
    <p id="$13">[13] Johan Scholliers and Hendrik Van Brussel. Computer-integrated filament winding: computer-integrated design, robotic filament winding and robotic quality control. Composites Manufacturing, 5(1):15-23, 1994.</p>
    <p id="$14">[14] Haisheng Li, Youdong Liang, and Hujun Bao. CAM system for filament winding on elbows. Journal of Materials Processing Technology, 161:491-496, 2005.</p>
    <p id="$15">[15] S. Koussios, O. K. Bergsma, and A. Beukers. Filament winding. Part 1: Determination of the wound body related parameters. Composites Part A: Applied Science and Manufacturing, 35:181-195, 2004.</p>
    <p id="$16">[16] Andrew Russell Forsyth. Lectures on the differential geometry of curves and surfaces. pages xxiii, 525 p., 1912.</p>
    <p id="$17">[17] Toponogov Rovenski. Differential geometry of curves and surfaces. 1976.</p>
    <p id="$18">[18] Paul A. Blaga. Lectures on Classical Differential Geometry. Editura Risoprint. 2005.</p>
    <p id="$19">[19] John Oprea. Differential Geometry and its Applications. 2007.</p>
    <p id="$20">[20] S.P. Gold. Filament Winding Surface of Revolution, Technical Report SCLDR-65-105, Sandia Corporation, Livermore Laboratory, Livermore, California. 1966.</p>
    <p id="$21">[21] Cheol U. Kim, Ji H. Kang, Chang S. Hong, and Chun G. Kim. Optimal design of filament wound structures under internal pressure based on the semi-geodesic path algorithm. Composite Structures, 67(4):443-452, 2005.</p>
    <p id="$22">[22] J. De Carvalho, M. Lossie, D. Vandepitte, and H. Van Brussel. Optimization of filament-wound parts based on non-geodesic winding. Composites Manufacturing, 6(2):79-84, 1995.</p>
    <p id="$23">[23] Jae Sung Park, Chang Sun Hong, Chun Gon Kim, and Cheol Ung Kim. Analysis of filament wound composite structures considering the change of winding angles through the thickness direction. Composite Structures, 55(1):63-71, 2002.</p>
    <p id="$24">[24] W Polini and L Sorrentino. Influence of winding speed and winding trajectory on tension in robotized filament winding of full section parts. Composites Science and Technology, 65(10):1574-1581, 2005.</p>
    <p id="$25">[25] S. Koussios, O. K. Bergsma, and a. Beukers. Filament winding. Part 2: Generic kinematic model and its solutions. Composites Part A: Applied Science and Manufacturing, 35:197-212, 2004.</p>
    <p id="$26">[26] S. Koussios, O.K. Bergsma, and a. Beukers. Filament winding: kinematics, collision control and process optimisation through application of dynamic programming. Composites Part A: Applied Science and Manufacturing, 37:2088-2104, 2006.</p>
    <p id="$27">[27] N. Vernet and F. Trochu. Analysis and modeling of 3D Interlock fabric compaction behavior. Composites Part A: Applied Science and Manufacturing,80:182-193, 2016.</p>
    <p id="$28">[28] Byung Chul Kim, Paul M. Weaver, and Kevin Potter. Computer Aided Modelling of Variable Angle Tow Composites Manufactured by Continuous Tow Shearing. Composite Structures, 129:256-267, 2015.</p>
  </section>
  <section id="apendix_a">
    <h1>Appendix A</h1>
    <h1>Matlab Code</h1>
    <h2>A.1 Pathwind</h2>
    <p>Página 1</p>
    <article class="code1">
      <pre>
        <code class="language-matlab">
        %Programa base
        %% Inicialização
        clear all; close all; clc;
        addpath([pwd,'\functions']);
        addpath([pwd,'\Resultados']);
        %% Dados
        %Mandril - caso conico, rfm>rim
        rim=15; %raio inicial mandril - caso cilindro, assume rc=rim
        rfm=15; %raio final mandril
        zim=-500; %z inicio mandril
        zfm=1000; %z final mandril
        %Zona util do mandril
        zig=0; %z inicio da zona de enrolamento geodésico
        zi=0; %z inicio do enrolamento tem de ser igual a zig
        zfg=300; %z final da zona de enrolamento geodésico
        %Alfa inicial zona geodésica (em zi)
        alfainicio=20; %alfa em graus. domínio: ]-90,90]
        %Coeficiente de escorregamento
        niu=0.14;
        lambda1=niu;
        %Incremento na curva
        ds=2;
        dsta=2; %ds no turnaround
        %Propriedades do material
        %largura de banda
        b=10;
        %number of rovings
        NR=10;
        %roving width (mm)
        RW=b/NR;
        %TEX value (g/km)
        TEX=800;
        %fibre volume content/ fibre mass content (%) - o que não se usa=0
        fvc=0;
        fmc=60;
        %fibre density (g/cm3)
        fibdens=1.77;
        %resin density (g/cm3)
        resdens=1.2;
        %Número de paths
        NP=6;
        %Velocidade da máquina
        vel=1.5; %multiplica pelo tempo necessário para cada passo
        </code>
      </pre>
    </article>
    <p>Página 2</p>
    <article class="code2">
      <pre><code class="language-matlab">
        %Outputs
        nomeoutput='04.03.2016_rc75_b10_-500,0,300,1000,alfa20'; %nome da pasta e
        ficheiros (sem espaços)
        filepath='C:\Users\Rodrigo\Dropbox\Tese\Programa';
        %Trajectórias
        gravartrajectorias='s'; %Se for para gravar, escrever 's' se nao, escrever outra
        coisa
        %CNC
        cnc='s';
        gravarcnc='s'; %Se for para gravar, escrever 's' se nao, escrever outra coisa
        %Distância da cabeça a ao mandril - distância fixa
        D=50;
        %Sections - sobreposições só funcionam com secções rectangulares
        seccoes='rectangular'; %rectangular ou eliptical
        belip=1; %espessura medida da fibra no caso eliptico
        %Sobreposições
        sobre='sobreposiçao2'; %'sobreposição1' - 1 ciclo. 'sobreposição2' - todos os
        ciclos 'sobreposição3' - matriz reorganizada ainda não funcional
        %% Machine Parameters
        %Reference
        RefA=0;
        RefX=0;
        RefY=260; %distancia do eixo Y ao fim da cabeça
        RefB=0;
        RefZ=0;
        RefC=0;
        %Dimensions
        Xmin=165.15; %mm
        Xmax=2644.7; %mm
        Ymin=-120; %mm
        Ymax=311; %mm
        Zmin=0; %mm
        Zmax=364; %mm
        Cmin=-50; %º
        Cmax=50; %º
        POew=50; %mm
        POe=0; %mm
        YawR=260; %mm
        %Velocity
        VA=150; %360º/min
        VX=1; %m/s
        VY=0.5; %m/s
        VB=115; %360º/min
        VZ=0.5; %m/s
        VC=100; %360º/min   
      </code></pre>
    </article>
    <p>Página 3</p>
    <article class="code3">
      <pre><code class="language-matlab">
        %Acceleration
        AA=8; %360º/min
        AX=4; %m/s
        AY=30; %m/s
        AB=60; %360º/min
        AZ=1; %m/s
        AC=45; %360º/min
        %Resolution
        RA=360; %inc/360º
        RX=1; %inc/mm
        RY=-1; %inc/mm
        RB=360; %inc/360º
        RZ=1; %inc/mm
        RC=360; %inc/360º
        %Processing time
        minproc=0.03; %minimium processing time (s)
        %Velocidades Máximas - inc/s
        VAmax=abs(VA*RA/60);
        VXmax=abs(VX*1000*RX);
        VYmax=abs(VY*1000*RY);
        VBmax=abs(VB*RB/60);
        VZmax=abs(VZ*1000*RZ);
        VCmax=abs(VC*RC/60);
        %Acelerações máximas
        AAmax=abs(AA*RA);
        AXmax=abs(AX*60*1000*RX);
        AYmax=abs(AY*60*1000*RY);
        ABmax=abs(AB*RB);
        AZmax=abs(AZ*60*1000*RZ);
        ACmax=abs(AC*RC);
        %% Cálculos iniciais
        alfai=alfainicio*pi/180; %alfa em rad
        lm=zfm-zim; %comprimento do mandril
        lg=zfg-zig; %comprimento zona geodésica
        dm=rfm-rim; %diferença de raio do mandril
        rig=((zig*dm/lm)+rim-(dm*zim/lm)); %raio no inicio da zona geodésica
        ri=((zi*dm/lm)+rim-(dm*zim/lm)); %raio na secção do inicio do enrolamento
        rfg=((zfg*dm/lm)+rim-(dm*zim/lm)); %raio no final da zona geodésica
        tau=atan(dm/lm);
        zeroteta=(zfg+zig)/2; %em coordenadas esféricas, o zero fica a meio
        rc=rim; %se for cilindro fica com o raio menor do mandril
        %Padrão cilindro
        if rig==rfg
      </code></pre>
    </article>
    <p>Página 4</p>
    <article class="code4">
      <pre><code class="language-matlab">
        beff=b/cos(alfai);
        nreal=2*pi*rc/beff;
        n1=ceil(nreal);
        end
        % Espessura
        fd=fmc*fibdens+(1-fmc)*resdens;
        esp=(fmc*(TEX/100000)/((RW/10)*(fd-(1-fmc)*resdens)))*10;
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %------------------------------------------------
        Mandril------------------------------------------------------
        %% Mandril
        % Gerar Mandril
        if rim==rfm
        tipomandril='cilindro' %cilindro ou cone
        else
        tipomandril='cone'
        end
        switch lower(tipomandril)
        case {'cilindro'}
        tc = 0:pi/20:2*pi;
        k=1;
        X=zeros(2,size(tc,2));
        Y=zeros(2,size(tc,2));
        Z=zeros(2,size(tc,2));
        for tc = 0:pi/20:2*pi
        X(1,k)=rc*cos(tc);
        X(2,k)=rc*cos(tc);
        Y(1,k)=rc*sin(tc);
        Y(2,k)=rc*sin(tc);
        Z(1,k)=zim;
        Z(2,k)=zfm;
        k=k+1;
        end
        case {'cone'}
        %Mandril
      </code></pre>
    </article>
    <p>Página 5</p>
    <article class="code5">
      <pre><code class="language-matlab">
        tc = 0:pi/20:2*pi;
        k=1;
        X=zeros(2,size(tc,2));
        Y=zeros(2,size(tc,2));
        Z=zeros(2,size(tc,2));
        for tc = 0:pi/20:2*pi
        X(1,k)=rim*cos(tc);
        X(2,k)=rfm*cos(tc);
        Y(1,k)=rim*sin(tc);
        Y(2,k)=rfm*sin(tc);
        Z(1,k)=zim;
        Z(2,k)=zfm;
        k=k+1;
        end
        otherwise
        %Mandril
        tc = 0:pi/20:2*pi;
        k=1;
        X=zeros(2,size(tc,2));
        Y=zeros(2,size(tc,2));
        Z=zeros(2,size(tc,2));
        for tc = 0:pi/20:2*pi
        X(1,k)=rim*cos(tc);
        X(2,k)=rim*cos(tc);
        Y(1,k)=rim*sin(tc);
        Y(2,k)=rim*sin(tc);
        Z(1,k)=zig;
        Z(2,k)=zig;
        k=k+1;
        end
        end
        %Superfície parametrizada para coordenadas esféicas ou polares
        if rim==rfm
        coordenadas='esfericas'
        else
        coordenadas='polares'
        end
        switch lower(coordenadas)
        case {'polares'}
        %% Superfície parametrizada do mandril em coordenadas polares
        %syms u v a(u) b(u) t
        %S=[a*cos(v),a*sin(v),b]; %S(u,v)=general shell of revolution
        % S=[cos(v)*cos(u), cos(v)*sin(u), sin(v)]
        %Cone
        syms fi ro
        %ro=((z*dm/lm)+rim-(dm*zim/lm));
      </code></pre>
    </article>
    <p>Página 6</p>
    <article class="code6">
      <pre><code class="language-matlab">
        z=ro*lm/dm-rim*lm/dm+zim;
        S=[ro*cos(fi), ro*sin(fi), ro*lm/dm-rim*lm/dm+zim];
        %% Propriedades da superfície - coordenadas polares
        %[chr,gg1,gg2,e,g,ev,eu,gv,gu]=Christoffel_funcao_1(S,u,v,ro)
        [chr,gg1,gg2,e,g,ero,efi,gro,gfi]=Christoffel_funcao_1(S,fi,ro,z)
        zlinha=diff(z,ro)
        z2linha=diff(zlinha,ro)
        case {'esfericas'}
        %% Superfície parametrizada do mandril em coordenadas esfericas
        %Cilindro
        syms teta fi ro
        ro=rc/sin(teta);
        Se=[ro*sin(teta)*cos(fi), ro*sin(teta)*sin(fi),ro*cos(teta)];
        %% Propriedades da superfície - coordenadas esfericas
        %[chr,gg1,gg2,e,g,ev,eu,gv,gu]=Christoffel_funcao_1(S,u,v,ro)
        [chr,gg1,gg2,e,g,eteta,efi,gteta,gfi]=Christoffel_funcao_1(Se,fi,teta,ro);
        end
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %--------------------------------------------------
        Trajectória1------------------------------------------------
        %% Trajectória da zona útil 1
        if rim==rfm
        traj1='cilindros analitica'
        else
        traj1='cones analitica'
        end
        switch lower(traj1)
        case {'cones analitica'}
        %% Trajectoria geodésica para cones - Koussios

      </code></pre>
    </article>
    <p>Página 7</p>
    <article class="code7">
      <pre><code class="language-matlab">
        c1=sin(alfai)*ri; %começando a trajetoria em ri
        z=[];
        fi=[];
        fi1=[];
        ro=[];
        alfa1=[];
        lf=[];
        alfa1(1,1)=alfai;
        z(1,1)=zi;
        ro(1,1)=((z(1,1)*dm/lm)+rim-(dm*zim/lm));
        fi1(1,1)=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro(1,1)));
        lf(1,1)=0;
        i=1;
        while z(1,i) < zfg
        i=i+1;
        z(1,i)=z(1,i-1)+ds*cos(alfa1(1,i-1))*cos(tau);
        ro(1,i)=((z(1,i)*dm/lm)+rim-(dm*zim/lm));
        fi1(1,i)=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro(1,i)));
        %alfa1(1,i)=atan((ro(1,i)*(fi1(1,i)-fi1(1,i-1)))/((z(1,i)-z(1,i-1))/cos
        (tau)));
        alfa1(1,i)=asin(c1/ro(1,i));
        dalfadro(1,i)=(alfa1(1,i)-alfa1(1,i-1))/(ro(1,i)-ro(1,i-1));
        lf(1,i)=lf(1,i-1)+ds;
        end
        dalfadro(1,1)=dalfadro(1,2);
        if z(1,i)~=zfg
        z(1,i)=zfg;
        ro(1,i)=((z(1,i)*dm/lm)+rim-(dm*zim/lm));
        fi1(1,i)=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro(1,i)));
        %alfa1(1,i)=atan((ro(1,i)*(fi1(1,i)-fi1(1,i-1)))/((z(1,i)-z(1,i-1))/cos
        (tau)));
        alfa1(1,i)=asin(c1/ro(1,i));
        lf(1,i)=lf(1,i-1)+(z(1,i)-z(1,i-1))/(cos(tau)*cos(alfa1(1,i-1)));
        dalfadro(1,i)=(alfa1(1,i)-alfa1(1,i-1))/(ro(1,i)-ro(1,i-1));
        end
        %alfa=zeros(1,size(alfa1,2));
        alfa=alfa1;
        %passo extra
        %i=i+1;
        %zpe=z(1,i-1)+0.00001*cos(alfa1(1,i-1))*cos(tau);
        %rope=((zpe*dm/lm)+rim-(dm*zim/lm));
        %fi1pe=(1/sin(tau))*(asin(c1/rfg)-asin(c1/rope));
        %alfa1(1,i)=atan((rope*(fi1pe-fi1(1,i-1)))/((zpe-z(1,i-1))/cos(tau)));

      </code></pre>
    </article>
    <p>Página 8</p>
    <article class="code8">
      <pre><code class="language-matlab">
        %for j=1:size(alfa,2)
        % alfa(1,j)=alfa1(1,j+1);
        %end
        fi(1,:)=fi1(1,:)-fi1(1,1);
        %Cartesianas
        x=ro.*cos(fi);
        y=ro.*sin(fi);
        case {'cones integral'} %coordenadas polares
        %% Cálculos iniciais
        fi=[];
        lf=[];
        alfa=[];t
        dalfadro=[];
        ro=[];
        z=[];
        alfa(1,1)=alfai;
        fi(1,1)=0;
        lf(1,1)=0;
        z(1,1)=zi;
        ro(1,1)=((z(1,1)*dm/lm)+rim-(dm*zim/lm));
        n=1;
        j=1;
        %% Cálculo de fi, alfa e Lf
        while z(1,n)< zfg
        ro(1,n+1)=ro(1,n)+ds*cos(alfa(1,n))*sin(tau);
        z(1,n+1)=ro(1,n+1)*lm/dm-rim*lm/dm+zim;
        dalfadro0=-0.5*ero*tan(alfa(1,n))/gg1(1,1);
        dalfadro1=-0.5*ero*tan(alfa(1,n))/gg1(1,1);
        dalfadro0=double(subs(dalfadro0,'ro',ro(1,n)));
        dalfadro0=double(subs(dalfadro0,'fi',fi(1,n)));
        dalfadro1=double(subs(dalfadro1,'ro',ro(1,n+1)));
        dalfadro1=double(subs(dalfadro1,'fi',fi(1,n)));
        dalfadro(1,n)=dalfadro0;
        alfa(1,n+1)=alfa(1,n)+(ro(1,n+1)-ro(1,n))*(dalfadro0+dalfadro1)/2;
        E1=vpa(subs(gg1(1,1),'ro',ro(1,n)));
        E1=vpa(subs(E1,'fi',fi(1,n)));
        G1=vpa(subs(gg1(2,2),'ro',ro(1,n)));
        G1=vpa(subs(G1,'fi',fi(1,n)));
      </code></pre>
    </article>
    <p>Página 9</p>
    <article class="code9">
      <pre><code class="language-matlab">
        E2=vpa(subs(gg1(1,1),'ro',ro(1,n+1)));
        E2=vpa(subs(E1,'fi',fi(1,n)));
        G2=vpa(subs(gg1(2,2),'ro',ro(1,n+1)));
        G2=vpa(subs(G1,'fi',fi(1,n)));
        n=n+1;
        fi(1,n)=fi(1,n-1)+0.5*(ro(1,n)-ro(1,n-1))*(tan(alfa(1,n-1))*sqrt(G1/E1)+tan
        (alfa(1,n))*sqrt(G2/E2)); %verificar contas
        lf(1,n)=lf(1,n-1)+0.5*(ro(1,n)-ro(1,n-1))*(sqrt(G1)/cos(alfa(1,n-1))+sqrt
        (G2)/cos(alfa(1,n))); %verificar contas
        end
        if z(1,n)~=zfg
        z(1,n)=zfg;
        ro(1,n)=((z(1,n)*dm/lm)+rim-(dm*zim/lm));
        dalfadro0=-0.5*ero*tan(alfa(1,n))/gg1(1,1);
        dalfadro1=-0.5*ero*tan(alfa(1,n))/gg1(1,1);
        dalfadro0=double(subs(dalfadro0,'ro',ro(1,n-1)));
        dalfadro1=double(subs(dalfadro1,'ro',ro(1,n)));
        dalfadro(1,n)=dalfadro0;
        alfa(1,n)=alfa(1,n-1)+(ro(1,n)-ro(1,n-1))*(dalfadro0+dalfadro1)/2;
        E1=vpa(subs(gg1(1,1),'ro',ro(1,n-1)));
        E1=vpa(subs(E1,'fi',fi(1,n-1)));
        G1=vpa(subs(gg1(2,2),'ro',ro(1,n-1)));
        G1=vpa(subs(G1,'fi',fi(1,n-1)));
        E2=vpa(subs(gg1(1,1),'ro',ro(1,n)));
        E2=vpa(subs(E1,'fi',fi(1,n-1)));
        G2=vpa(subs(gg1(2,2),'ro',ro(1,n)));
        G2=vpa(subs(G1,'fi',fi(1,n-1)));
        fi(1,n)=fi(1,n-1)+0.5*(ro(1,n)-ro(1,n-1))*(tan(alfa(1,n-1))*sqrt(G1/E1)+tan
        (alfa(1,n))*sqrt(G2/E2)); %verificar contas
        lf(1,n)=lf(1,n-1)+0.5*(ro(1,n)-ro(1,n-1))*(sqrt(G1)/cos(alfa(1,n-1))+sqrt
        (G2)/cos(alfa(1,n))); %verificar contas
        end
        %% Cartesianas
        x=ro.*cos(fi);
        y=ro.*sin(fi);
        case {'cilindros analitica'}
        %% Trajectória geodésica para cilindros - hélices
        % Helice e superficie
        dz=ds*cos(alfai);
        z=[];
        z(1,:)=zi:dz:zfg;
      </code></pre>
    </article>
    <p>Página 10</p>
    <article class="code10">
      <pre><code class="language-matlab">
        if z(1,size(z,2))~=zfg
        z(1,size(z,2)+1)=zfg;
        end
        c=rc/tan(alfai);
        fi=z/c;
        x=rc*cos(fi);
        y=rc*sin(fi);
        %para dar continuidade estes dados são necessários no TA
        alfa=ones(1,size(x,2)).*alfai;
        lf=sqrt((fi.*rc).^2+(z-zig).^2); %fazer contas outra vez
        tetai=atan(rc/(lg/2));
        tetaf=pi-tetai;
        dalfadteta=zeros(1,size(x,2));
        teta=atan(rc./(zeroteta-z));
        tetap=[];
        tetap(1,1)=teta(1,1);
        for n=1:size(teta,2)
        if teta(1,n)< 0
        tetap(1,n)=teta(1,n)+pi;
        else
        tetap(1,n)=teta(1,n);
        end
        end
        if z(1,size(z,2))~=zfg
        z(1,size(z,2)+1)=zfg;
        end
        case {'cilindros integral'} %coordenadas esfericas
        %% Cálculos iniciais
        tetai=atan(rc/(lg/2-zi));
        tetaf=pi-atan(rc/(lg/2));
        fi=[];
        lf=[];
        alfa=[];
        dalfadteta=[];
        alfa(1,1)=alfai;
        teta=[];
        teta1=tetai;
      </code></pre>
    </article>
    <p>Página 11</p>
    <article class="code11">
      <pre><code class="language-matlab">
        teta(1,1)=teta1;
        tetap=[];
        tetap(1,1)=tetai;
        fi(1,1)=0;
        lf(1,1)=0;
        n=1;
        j=1;
        %% Cálculo de fi, alfa e Lf
        while tetap(1,n)< tetaf
        %Gerar teta para ds constante
        j=n+1;
        teta(1,j)=teta1;
        teta2=atan(1/(-(ds*cos(alfa(1,n)))/rc+1/tan(teta1)));
        teta1=teta2;
        if teta(1,j)< 0
        tetap(1,j)=teta(1,j)+pi;
        else
        tetap(1,j)=teta(1,j);
        end
        dalfadteta0=0.5*eteta*tan(alfa(1,n))/gg1(1,1);
        dalfadteta1=0.5*eteta*tan(alfa(1,n))/gg1(1,1);
        dalfadteta0=double(subs(dalfadteta0,'teta',tetap(1,n)));
        dalfadteta1=double(subs(dalfadteta1,'teta',tetap(1,n+1)));
        dalfadteta(1,n)=dalfadteta0;
        alfa(1,n+1)=alfa(1,n)+(tetap(1,n+1)-tetap(1,n))*(dalfadteta0+dalfadteta1)
        /2;
        E1=vpa(subs(gg1(1,1),'teta',tetap(1,n)));
        E1=vpa(subs(E1,'fi',fi(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetap(1,n)));
        G1=vpa(subs(G1,'fi',fi(1,n)));
        E2=vpa(subs(gg1(1,1),'teta',tetap(1,n+1)));
        E2=vpa(subs(E1,'fi',fi(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetap(1,n+1)));
        G2=vpa(subs(G1,'fi',fi(1,n)));
        n=n+1;
        fi(1,n)=fi(1,n-1)+0.5*(tetap(1,n)-tetap(1,n-1))*(tan(alfa(1,n-1))*sqrt
        (G1/E1)+tan(alfa(1,n))*sqrt(G2/E2));
        lf(1,n)=lf(1,n-1)+0.5*(tetap(1,n)-tetap(1,n-1))*(sqrt(G1)/cos(alfa(1,n-1))
        +sqrt(G2)/cos(alfa(1,n)));

      </code></pre>
    </article>
    <p>Página 12</p>
    <article class="code12">
      <pre><code class="language-matlab">
        end
        %ultimo passo
        if tetap(1,n-1)~=tetaf
        tetap(1,n)=tetaf;
        dalfadteta0=0.5*eteta*tan(alfa(1,n))/gg1(1,1);
        dalfadteta1=0.5*eteta*tan(alfa(1,n))/gg1(1,1);
        dalfadteta0=double(subs(dalfadteta0,'teta',tetap(1,n)));
        dalfadteta1=double(subs(dalfadteta1,'teta',tetap(1,n+1)));
        dalfadteta(1,n)=dalfadteta0;
        alfa(1,n+1)=alfa(1,n)+(tetap(1,n+1)-tetap(1,n))*(dalfadteta0+dalfadteta1)
        /2;
        E1=vpa(subs(gg1(1,1),'teta',tetap(1,n)));
        E1=vpa(subs(E1,'fi',fi(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetap(1,n)));
        G1=vpa(subs(G1,'fi',fi(1,n)));
        E2=vpa(subs(gg1(1,1),'teta',tetap(1,n+1)));
        E2=vpa(subs(E1,'fi',fi(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetap(1,n+1)));
        G2=vpa(subs(G1,'fi',fi(1,n)));
        n=n+1;
        fi(1,n)=fi(1,n-1)+0.5*(tetap(1,n)-tetap(1,n-1))*(tan(alfa(1,n-1))*sqrt
        (G1/E1)+tan(alfa(1,n))*sqrt(G2/E2));
        lf(1,n)=lf(1,n-1)+0.5*(tetap(1,n)-tetap(1,n-1))*(sqrt(G1)/cos(alfa(1,n-1))
        +sqrt(G2)/cos(alfa(1,n)));
        end
        %% Cartesianas
        ro=rc./sin(tetap);
        x=ro.*sin(tetap).*cos(fi);
        y=ro.*sin(tetap).*sin(fi);
        z=-ro.*cos(tetap)+zeroteta;
        end
        %%
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %
        --------------------------------------------------------------------------------------
        ------------------------
      </code></pre>
    </article>
    <p>Página 13</p>
    <article class="code13">
      <pre><code class="language-matlab">
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %---------------------------------------------------
        Turnaround1------------------------------------------------
        %% Turnaround 1
        if rim==rfm
        turnaround='cilindro'
        else
        turnaround='cone'
        end
        switch lower(turnaround)
        case {'cilindro'}
        %% Cálculos iniciais
        alfaita=alfa(1,size(alfa,2));
        teta1=tetaf;
        tetata=[];
        tetata(1,1)=teta1;
        tetatap=[];
        tetatap(1,1)=teta1;
        alfata=[];
        alfata(1,1)=alfaita;
        fita=[];
        fita(1,1)=fi(1,size(fi,2));
        lfta=[];
        lfta(1,1)=lf(1,size(lf,2));
        dalfadtetata=[];
        dalfadtetata(1,1)=dalfadteta(1,size(dalfadteta,2));
        n=1;
        j=1;
        %% Primeira metade
        while alfata(1,n)< pi/2
        %Gerar teta para ds constante
        j=j+1;
        tetata(1,j)=teta1;
        teta2=atan(1/(-(dsta*cos(alfata(1,n)))/rc+1/tan(teta1)));
        teta1=teta2;
      </code></pre>
    </article>
    <p>Página 14</p>
    <article class="code14">
      <pre><code class="language-matlab">
        if tetata(1,j)< 0
        tetatap(1,j)=tetata(1,j)+pi;
        else
        tetatap(1,j)=tetata(1,j);
        end
        %Cálculo das formas fundamentais em tetatap(1,n)
        E1=vpa(subs(gg1(1,1),'teta',tetatap(1,n)));
        E1=vpa(subs(E1,'fi',fita(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetatap(1,n)));
        G1=vpa(subs(G1,'fi',fita(1,n)));
        L1=vpa(subs(gg2(1,1),'teta',tetatap(1,n)));
        L1=vpa(subs(L1,'fi',fita(1,n)));
        N1=vpa(subs(gg2(2,2),'teta',tetatap(1,n)));
        N1=vpa(subs(N1,'fi',fita(1,n)));
        %Cálculo de dalfadteta em tetatap(1,n)
        dalfadtetata0=0.5*eteta*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt(G1)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        %Cálculo das formas fundamentais em tetatap(1,n+1)
        E2=vpa(subs(gg1(1,1),'teta',tetatap(1,n+1)));
        E2=vpa(subs(E2,'fi',fita(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetatap(1,n+1)));
        G2=vpa(subs(G2,'fi',fita(1,n)));
        L2=vpa(subs(gg2(1,1),'teta',tetatap(1,n+1)));
        L2=vpa(subs(L2,'fi',fita(1,n)));
        N2=vpa(subs(gg2(2,2),'teta',tetatap(1,n+1)));
        N2=vpa(subs(N2,'fi',fita(1,n)));
        %Cálculo de dalfadteta em tetatap(1,n)
        dalfadtetata1=0.5*eteta*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt(G2)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N2/G2)+((sin(alfata(1,n))^2)*L2/E2)));
        dalfadtetata(1,n)=dalfadtetata0;
        %Cálculo de alfa
        alfata(1,n+1)=alfata(1,n)+(tetatap(1,n+1)-tetatap(1,n))*
        (dalfadtetata0+dalfadtetata1)/2;
        %Cálculo de fi e Lf
        fita(1,n+1)=fita(1,n)+0.5*(tetatap(1,n+1)-tetatap(1,n))*(tan(alfata(1,n))
        *sqrt(G1/E1)+tan(alfata(1,n+1))*sqrt(G2/E2));
        lfta(1,n+1)=lfta(1,n)+0.5*(tetatap(1,n+1)-tetatap(1,n))*(sqrt(G1)/cos
        (alfata(1,n))+sqrt(G2)/cos(alfata(1,n+1)));
        n=n+1;
        end
        dalfadtetata(1,n)=dalfadtetata(1,n-1);
        alfata(1,n)=pi/2;
      </code></pre>
    </article>
    <p>Página 15</p>
    <article class="code15">
      <pre><code class="language-matlab">
        %% Dwell
        nmeio=n;
        alfatameio=alfata(1,n);
        fitameio=fita(1,n);
        dfita=dsta/rc;
        deltafita=fita(1,n)-fita(1,1);
        fitafin1=fita(1,n)+deltafita;
        fitafin2=2*fitafin1;
        p=1;
        while fitafin2>p*2*pi
        p=p+1;
        end
        dif=p*2*pi-fitafin2;
        if dif/2-pi/n1>=0
        fidwell=dif/2-pi/n1;
        else
        fidwell=dif/2+pi/n1;
        end
        while fita(1,n)< fitameio+fidwell
        n=n+1;
        fita(1,n)=fita(1,n-1)+dfita;
        lfta(1,n)=lfta(1,n-1)+rc*dfita;
        alfata(1,n)=pi/2;
        dalfadtetata(1,n)=dalfadtetata(1,n-1);
        tetata(1,n)=tetata(1,n-1);
        tetatap(1,n)=tetatap(1,n-1);
        end
        fita(1,n)=fita(1,nmeio)+fidwell;
        lfta(1,n)=lfta(1,n-1)+rc*(fita(1,n)-fita(1,n-1));
        nfimrest=n;
        teta1=tetatap(1,n);
        j=n;
        %% Segunda metade
        parte2turnaround='simetrico'
        switch lower(parte2turnaround)
        case {'integral'}
        while alfata(1,n)<(pi-alfaita)
        %Gerar teta para ds constante
        j=j+1;
        tetata(1,j)=teta1;
      </code></pre>
    </article>
    <p>Página 16</p>
    <article class="code16">
      <pre><code class="language-matlab">
        teta2=atan(1/(-(dsta*cos(alfata(1,n)))/rc+1/tan(teta1)));
        teta1=teta2;
        if tetata(1,j)< 0
        tetatap(1,j)=tetata(1,j)+pi;
        else
        tetatap(1,j)=tetata(1,j);
        end
        E1=vpa(subs(gg1(1,1),'teta',tetatap(1,n)));
        E1=vpa(subs(E1,'fi',fita(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetatap(1,n)));
        G1=vpa(subs(G1,'fi',fita(1,n)));
        L1=vpa(subs(gg2(1,1),'teta',tetatap(1,n)));
        L1=vpa(subs(L1,'fi',fita(1,n)));
        N1=vpa(subs(gg2(2,2),'teta',tetatap(1,n)));
        N1=vpa(subs(N1,'fi',fita(1,n)));
        dalfadtetata0=0.5*eteta*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt
        (G1)/cos(alfata(1,n)))*(((cos(alfata(1,n))^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        E2=vpa(subs(gg1(1,1),'teta',tetatap(1,n+1)));
        E2=vpa(subs(E2,'fi',fita(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetatap(1,n+1)));
        G2=vpa(subs(G2,'fi',fita(1,n)));
        L2=vpa(subs(gg2(1,1),'teta',tetatap(1,n+1)));
        L2=vpa(subs(L2,'fi',fita(1,n)));
        N2=vpa(subs(gg2(2,2),'teta',tetatap(1,n+1)));
        N2=vpa(subs(N2,'fi',fita(1,n)));
        dalfadtetata1=0.5*eteta*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt
        (G2)/cos(alfata(1,n)))*(((cos(alfata(1,n))^2)*N2/G2)+((sin(alfata(1,n))^2)*L2/E2)));
        dalfadtetata(1,n)=dalfadtetata0;
        alfata(1,n+1)=alfata(1,n)+(tetatap(1,n+1)-tetatap(1,n))*
        (dalfadtetata0+dalfadtetata1)/2;
        fita(1,n+1)=fita(1,n)+0.5*(tetatap(1,n+1)-tetatap(1,n))*(tan
        (alfata(1,n))*sqrt(G1/E1)+tan(alfata(1,n+1))*sqrt(G2/E2));
        lfta(1,n+1)=lfta(1,n)+0.5*(tetatap(1,n+1)-tetatap(1,n))*(sqrt(G1)
        /cos(alfata(1,n))+sqrt(G2)/cos(alfata(1,n+1)));
        n=n+1;
        end
        case {'simetrico'}
        for i=0:nmeio-1
        n=n+1;
        fita(1,nfimrest+i)=fita(1,nfimrest)+fita(1,nmeio)-fita(1,nmeio-i);

      </code></pre>
    </article>
    <p>Página 17</p>
    <article class="code17">
      <pre><code class="language-matlab">
        lfta(1,nfimrest+i)=lfta(1,nfimrest)+lfta(1,nmeio)-lfta(1,nmeio-i);
        alfata(1,nfimrest+i)=alfata(1,nmeio)+(alfata(1,nmeio)-alfata(1,
        nmeio-i));
        tetatap(1,nfimrest+i)=tetatap(1,nmeio-i);
        tetata(1,nfimrest+i)=tetatap(1,nmeio-i);
        dalfadtetata(1,nfimrest+i)=-dalfadtetata(1,nmeio-i);
        end
        n=n-1;
        end
        nfinal=n;
        alfafinal=alfata(1,n);
        fitafinal=fita(1,n);
        % Cartesianas
        rota=rc./sin(tetatap);
        xta=rota.*sin(tetatap).*cos(fita);
        yta=rota.*sin(tetatap).*sin(fita);
        zta=-rota.*cos(tetatap)+zeroteta;
        case {'cone'}
        %% Cálculos iniciais
        alfaita=alfa(1,size(alfa,2));
        %Padrão - sempre a assumir rfg>rig
        beff=b/cos(alfaita);
        nreal=2*pi*ro(1,size(ro,2)-1)/beff;
        n1=ceil(nreal);
        alfata=[];
        alfata(1,1)=alfaita;
        alfata21=[];
        alfata21(1,1)=pi-alfai;
        fita=[];
        fita(1,1)=fi(1,size(fi,2));
        fita21=[];
        fita21(1,1)=0;
        lfta=[];
        lfta(1,1)=lf(1,size(lf,2));
        lfta21=[];
        lfta21(1,1)=0;
        dalfadrota=[];
        dalfadrota(1,1)=dalfadro(1,size(dalfadro,2));
      </code></pre>
    </article>
    <p>Página 18</p>
    <article class="code18">
      <pre><code class="language-matlab">
        dalfadrota21=[];
        dalfadrota21(1,1)=-dalfadro(1,1);
        rota=[];
        rota(1,1)=ro(1,size(ro,2));
        rota21=[];
        rota21(1,1)=rig;
        zta=[];
        zta(1,1)=z(1,size(z,2));
        zta21=[];
        zta21(1,1)=zig;
        n=1;
        nta=1;
        if alfaita< 0
        %% Primeira metade do TA1
        while alfata(1,n)>-pi/2
        rota(1,n+1)=rota(1,n)+ds*cos(alfata(1,n))*sin(tau);
        zta(1,n+1)=rota(1,n+1)*lm/dm-rim*lm/dm+zim;
        %Cálculo das formas fundamentais em rota(1,n)
        E1=vpa(subs(gg1(1,1),'ro',rota(1,n)));
        E1=vpa(subs(E1,'fi',fita(1,n)));
        G1=vpa(subs(gg1(2,2),'ro',rota(1,n)));
        G1=vpa(subs(G1,'fi',fita(1,n)));
        L1=vpa(subs(gg2(1,1),'ro',rota(1,n)));
        L1=vpa(subs(L1,'fi',fita(1,n)));
        N1=vpa(subs(gg2(2,2),'ro',rota(1,n)));
        N1=vpa(subs(N1,'fi',fita(1,n)));
        %Cálculo de dalfadro em rota(1,n)
        dalfadrota0=-0.5*ero*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt(G1)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        lambdacenas2(1,n)=lambda1*((sqrt(G1)/cos(alfata(1,n)))*(((cos(alfata(1,n))
        ^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        lambdacenas21(1,n)=double(subs(lambdacenas2(1,n),'ro',rota(1,n)));
        %Cálculo das formas fundamentais em rota(1,n+1)
        E2=vpa(subs(gg1(1,1),'ro',rota(1,n+1)));
        E2=vpa(subs(E2,'fi',fita(1,n)));
        G2=vpa(subs(gg1(2,2),'ro',rota(1,n+1)));
        G2=vpa(subs(G2,'fi',fita(1,n)));
        L2=vpa(subs(gg2(1,1),'ro',rota(1,n+1)));
        L2=vpa(subs(L2,'fi',fita(1,n)));
        N2=vpa(subs(gg2(2,2),'ro',rota(1,n+1)));
      </code></pre>
    </article>
    <p>Página 19</p>
    <article class="code19">
      <pre><code class="language-matlab">
        N2=vpa(subs(N2,'fi',fita(1,n)));
        %Cálculo de dalfadro em rota(1,n)
        dalfadrota1=-0.5*ero*tan(alfata(1,n))/gg1(1,1)+lambda1*((sqrt(G2)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N2/G2)+((sin(alfata(1,n))^2)*L2/E2)));
        dalfadrota0=double(subs(dalfadrota0,'ro',rota(1,n)));
        dalfadrota1=double(subs(dalfadrota1,'ro',rota(1,n+1)));
        dalfadrota(1,n)=dalfadrota0;
        %Cálculo de alfa
        alfata(1,n+1)=alfata(1,n)+(rota(1,n+1)-rota(1,n))*
        (dalfadrota0+dalfadrota1)/2;
        %Cálculo de fi e Lf
        fita(1,n+1)=fita(1,n)+0.5*(rota(1,n+1)-rota(1,n))*(tan(alfata(1,n))*sqrt
        (G1/E1)+tan(alfata(1,n+1))*sqrt(G2/E2));
        lfta(1,n+1)=lfta(1,n)+0.5*(rota(1,n+1)-rota(1,n))*(sqrt(G1)/cos(alfata(1,
        n))+sqrt(G2)/cos(alfata(1,n+1)));
        n=n+1;
        end
        dalfadrota(1,n)=dalfadrota(1,n-1);
        dfi=fi(1,size(fi,2))-fi(1,1);
        dfita=fita(1,size(fita,2))-fita(1,1);
        fitameio=fita(1,n);
        nmeio=n;
        disp('fim TA1')
        %% Primeira metade do TA2
        alfata21(1,1)=-pi-alfai;
        while alfata21(1,nta)<-pi/2
        rota21(1,nta+1)=rota21(1,nta)-ds*cos(alfata21(1,nta))*sin(tau);
        zta21(1,nta+1)=rota21(1,nta+1)*lm/dm-rim*lm/dm+zim;
        %Cálculo das formas fundamentais em tetatap(1,n)
        E1=vpa(subs(gg1(1,1),'ro',rota21(1,nta)));
        E1=vpa(subs(E1,'fi',fita21(1,nta)));
        G1=vpa(subs(gg1(2,2),'ro',rota21(1,nta)));
        G1=vpa(subs(G1,'fi',fita21(1,nta)));
        L1=vpa(subs(gg2(1,1),'ro',rota21(1,nta)));
        L1=vpa(subs(L1,'fi',fita21(1,nta)));
        N1=vpa(subs(gg2(2,2),'ro',rota21(1,nta)));
        N1=vpa(subs(N1,'fi',fita21(1,nta)));

      </code></pre>
    </article>
    <p>Página 20</p>
    <article class="code20">
      <pre><code class="language-matlab">
        %Cálculo de dalfadteta em tetatap(1,n)
        dalfadrota0=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)-lambda1*((sqrt(G1)/cos
        (alfata21(1,nta)))*(((cos(alfata21(1,nta))^2)*N1/G1)+((sin(alfata21(1,nta))^2)
        *L1/E1)));
        %dalfadrota0=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)+lambda1*((1/cos
        (alfata21(1,nta)))*(((zlinha+zlinha^3-rota21(1,nta)*z2linha)/(rota21(1,nta)*
        (1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/(1+zlinha^2)));
        lambdacenas(1,nta)=lambda1*((sqrt(G1)/cos(alfata21(1,nta)))*(((cos
        (alfata21(1,nta))^2)*N1/G1)+((sin(alfata21(1,nta))^2)*L1/E1)));
        lambdacenasz(1,nta)=lambda1*((1/cos(alfata21(1,nta)))*(((zlinha+zlinha^3-
        rota21(1,nta)*z2linha)/(rota21(1,nta)*(1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/
        (1+zlinha^2)));
        geocenas(1,nta)=0.5*ero*tan(alfata21(1,nta))/gg1(1,1);
        %Cálculo das formas fundamentais em tetatap(1,n+1)
        E2=vpa(subs(gg1(1,1),'ro',rota21(1,nta+1)));
        E2=vpa(subs(E2,'fi',fita21(1,nta)));
        G2=vpa(subs(gg1(2,2),'ro',rota21(1,nta+1)));
        G2=vpa(subs(G2,'fi',fita21(1,nta)));
        L2=vpa(subs(gg2(1,1),'ro',rota21(1,nta+1)));
        L2=vpa(subs(L2,'fi',fita21(1,nta)));
        N2=vpa(subs(gg2(2,2),'ro',rota21(1,nta+1)));
        N2=vpa(subs(N2,'fi',fita21(1,nta)));
        %Cálculo de dalfadteta em tetatap(1,n)
        %dalfadrota1=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)+lambda1*((1/cos
        (alfata21(1,nta)))*(((zlinha+zlinha^3-rota21(1,nta+1)*z2linha)/(rota21(1,nta+1)*
        (1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/(1+zlinha^2)));
        dalfadrota1=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)-lambda1*((sqrt(G2)/cos
        (alfata21(1,nta)))*(((cos(alfata21(1,nta))^2)*N2/G2)+((sin(alfata21(1,nta))^2)
        *L2/E2)));
        dalfadrota0=double(subs(dalfadrota0,'ro',rota21(1,nta)));
        dalfadrota1=double(subs(dalfadrota1,'ro',rota21(1,nta+1)));
        lambdacenas1(1,nta)=double(subs(lambdacenas(1,nta),'ro',rota21(1,nta)));
        lambdacenasz1(1,nta)=double(subs(lambdacenasz(1,nta),'ro',rota21(1,nta)));
        geocenas1(1,nta)=double(subs(geocenas(1,nta),'ro',rota21(1,nta)));
        dalfadrota21(1,nta)=dalfadrota0;
        %Cálculo de alfa
        alfata21(1,nta+1)=alfata21(1,nta)+abs(rota21(1,nta+1)-rota21(1,nta))*abs
        (dalfadrota0+dalfadrota1)/2;
        %Cálculo de fi e Lf
        fita21(1,nta+1)=fita21(1,nta)+0.5*(rota21(1,nta+1)-rota21(1,nta))*(tan
        (alfata21(1,nta))*sqrt(G1/E1)+tan(alfata21(1,nta+1))*sqrt(G2/E2));
        lfta21(1,nta+1)=lfta21(1,nta)+0.5*(rota21(1,nta+1)-rota21(1,nta))*(sqrt
        (G1)/cos(alfata21(1,nta))+sqrt(G2)/cos(alfata21(1,nta+1)));
        nta=nta+1;
        end
      </code></pre>
    </article>
    <p>Página 21</p>
    <article class="code21">
      <pre><code class="language-matlab">
        nmeio2=nta;
        disp('fim TA2')
        dalfadrota21(1,nta)=dalfadrota21(1,nta-1);
        dfita21=fita21(1,size(fita21,2))-fita21(1,1);
        else
        %% Primeira metade do TA1
        while alfata(1,n)< pi/2
        rota(1,n+1)=rota(1,n)+ds*cos(alfata(1,n))*sin(tau);
        zta(1,n+1)=rota(1,n+1)*lm/dm-rim*lm/dm+zim;
        %Cálculo das formas fundamentais em rota(1,n)
        E1=vpa(subs(gg1(1,1),'ro',rota(1,n)));
        E1=vpa(subs(E1,'fi',fita(1,n)));
        G1=vpa(subs(gg1(2,2),'ro',rota(1,n)));
        G1=vpa(subs(G1,'fi',fita(1,n)));
        L1=vpa(subs(gg2(1,1),'ro',rota(1,n)));
        L1=vpa(subs(L1,'fi',fita(1,n)));
        N1=vpa(subs(gg2(2,2),'ro',rota(1,n)));
        N1=vpa(subs(N1,'fi',fita(1,n)));
        %Cálculo de dalfadro em rota(1,n)
        dalfadrota0=-0.5*ero*tan(alfata(1,n))/gg1(1,1)-lambda1*((sqrt(G1)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        lambdacenas2(1,n)=lambda1*((sqrt(G1)/cos(alfata(1,n)))*(((cos(alfata(1,n))
        ^2)*N1/G1)+((sin(alfata(1,n))^2)*L1/E1)));
        lambdacenas21(1,n)=double(subs(lambdacenas2(1,n),'ro',rota(1,n)));
        %Cálculo das formas fundamentais em rota(1,n+1)
        E2=vpa(subs(gg1(1,1),'ro',rota(1,n+1)));
        E2=vpa(subs(E2,'fi',fita(1,n)));
        G2=vpa(subs(gg1(2,2),'ro',rota(1,n+1)));
        G2=vpa(subs(G2,'fi',fita(1,n)));
        L2=vpa(subs(gg2(1,1),'ro',rota(1,n+1)));
        L2=vpa(subs(L2,'fi',fita(1,n)));
        N2=vpa(subs(gg2(2,2),'ro',rota(1,n+1)));
        N2=vpa(subs(N2,'fi',fita(1,n)));
        %Cálculo de dalfadro em rota(1,n)
        dalfadrota1=-0.5*ero*tan(alfata(1,n))/gg1(1,1)-lambda1*((sqrt(G2)/cos
        (alfata(1,n)))*(((cos(alfata(1,n))^2)*N2/G2)+((sin(alfata(1,n))^2)*L2/E2)));
        dalfadrota0=double(subs(dalfadrota0,'ro',rota(1,n)));
        dalfadrota1=double(subs(dalfadrota1,'ro',rota(1,n+1)));
        dalfadrota(1,n)=dalfadrota0;

      </code></pre>
    </article>
    <p>Página 22</p>
    <article class="code22">
      <pre><code class="language-matlab">
        %Cálculo de alfa
        alfata(1,n+1)=alfata(1,n)+(rota(1,n+1)-rota(1,n))*
        (dalfadrota0+dalfadrota1)/2;
        %Cálculo de fi e Lf
        fita(1,n+1)=fita(1,n)+0.5*(rota(1,n+1)-rota(1,n))*(tan(alfata(1,n))*sqrt
        (G1/E1)+tan(alfata(1,n+1))*sqrt(G2/E2));
        lfta(1,n+1)=lfta(1,n)+0.5*(rota(1,n+1)-rota(1,n))*(sqrt(G1)/cos(alfata(1,
        n))+sqrt(G2)/cos(alfata(1,n+1)));
        n=n+1;
        end
        dalfadrota(1,n)=dalfadrota(1,n-1);
        dfi=fi(1,size(fi,2))-fi(1,1);
        dfita=fita(1,size(fita,2))-fita(1,1);
        fitameio=fita(1,n);
        nmeio=n;
        disp('fim TA1')
        %% Primeira metade do TA2
        alfata21(1,1)=pi-alfai;
        while alfata21(1,nta)>pi/2
        rota21(1,nta+1)=rota21(1,nta)+ds*cos(alfata21(1,nta))*sin(tau);
        zta21(1,nta+1)=rota21(1,nta+1)*lm/dm-rim*lm/dm+zim;
        %Cálculo das formas fundamentais em tetatap(1,n)
        E1=vpa(subs(gg1(1,1),'ro',rota21(1,nta)));
        E1=vpa(subs(E1,'fi',fita21(1,nta)));
        G1=vpa(subs(gg1(2,2),'ro',rota21(1,nta)));
        G1=vpa(subs(G1,'fi',fita21(1,nta)));
        L1=vpa(subs(gg2(1,1),'ro',rota21(1,nta)));
        L1=vpa(subs(L1,'fi',fita21(1,nta)));
        N1=vpa(subs(gg2(2,2),'ro',rota21(1,nta)));
        N1=vpa(subs(N1,'fi',fita21(1,nta)));
        %Cálculo de dalfadteta em tetatap(1,n)
        dalfadrota0=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)-lambda1*((sqrt(G1)/cos
        (alfata21(1,nta)))*(((cos(alfata21(1,nta))^2)*N1/G1)+((sin(alfata21(1,nta))^2)
        *L1/E1)));
        %dalfadrota0=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)+lambda1*((1/cos
        (alfata21(1,nta)))*(((zlinha+zlinha^3-rota21(1,nta)*z2linha)/(rota21(1,nta)*
        (1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/(1+zlinha^2)));
        lambdacenas(1,nta)=lambda1*((sqrt(G1)/cos(alfata21(1,nta)))*(((cos
        (alfata21(1,nta))^2)*N1/G1)+((sin(alfata21(1,nta))^2)*L1/E1)));

      </code></pre>
    </article>
    <p>Página 23</p>
    <article class="code23">
      <pre><code class="language-matlab">
        lambdacenasz(1,nta)=lambda1*((1/cos(alfata21(1,nta)))*(((zlinha+zlinha^3-
        rota21(1,nta)*z2linha)/(rota21(1,nta)*(1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/
        (1+zlinha^2)));
        geocenas(1,nta)=0.5*ero*tan(alfata21(1,nta))/gg1(1,1);
        %Cálculo das formas fundamentais em tetatap(1,n+1)
        E2=vpa(subs(gg1(1,1),'ro',rota21(1,nta+1)));
        E2=vpa(subs(E2,'fi',fita21(1,nta)));
        G2=vpa(subs(gg1(2,2),'ro',rota21(1,nta+1)));
        G2=vpa(subs(G2,'fi',fita21(1,nta)));
        L2=vpa(subs(gg2(1,1),'ro',rota21(1,nta+1)));
        L2=vpa(subs(L2,'fi',fita21(1,nta)));
        N2=vpa(subs(gg2(2,2),'ro',rota21(1,nta+1)));
        N2=vpa(subs(N2,'fi',fita21(1,nta)));
        %Cálculo de dalfadteta em tetatap(1,n)
        %dalfadrota1=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)+lambda1*((1/cos
        (alfata21(1,nta)))*(((zlinha+zlinha^3-rota21(1,nta+1)*z2linha)/(rota21(1,nta+1)*
        (1+zlinha^2)))*sin(alfata21(1,nta))^2+z2linha/(1+zlinha^2)));
        dalfadrota1=-0.5*ero*tan(alfata21(1,nta))/gg1(1,1)-lambda1*((sqrt(G2)/cos
        (alfata21(1,nta)))*(((cos(alfata21(1,nta))^2)*N2/G2)+((sin(alfata21(1,nta))^2)
        *L2/E2)));
        dalfadrota0=double(subs(dalfadrota0,'ro',rota21(1,nta)));
        dalfadrota1=double(subs(dalfadrota1,'ro',rota21(1,nta+1)));
        lambdacenas1(1,nta)=double(subs(lambdacenas(1,nta),'ro',rota21(1,nta)));
        lambdacenasz1(1,nta)=double(subs(lambdacenasz(1,nta),'ro',rota21(1,nta)));
        geocenas1(1,nta)=double(subs(geocenas(1,nta),'ro',rota21(1,nta)));
        dalfadrota21(1,nta)=dalfadrota0;
        %Cálculo de alfa
        alfata21(1,nta+1)=alfata21(1,nta)+(rota21(1,nta+1)-rota21(1,nta))*abs
        (dalfadrota0+dalfadrota1)/2;
        %Cálculo de fi e Lf
        fita21(1,nta+1)=fita21(1,nta)+0.5*(rota21(1,nta+1)-rota21(1,nta))*(tan
        (alfata21(1,nta))*sqrt(G1/E1)+tan(alfata21(1,nta+1))*sqrt(G2/E2));
        lfta21(1,nta+1)=lfta21(1,nta)+0.5*abs(rota21(1,nta+1)-rota21(1,nta))*(sqrt
        (G1)/cos(alfata21(1,nta))+sqrt(G2)/cos(alfata21(1,nta+1)));
        nta=nta+1;
        end
        nmeio2=nta;
        disp('fim TA2')
        dalfadrota21(1,nta)=dalfadrota21(1,nta-1);
        dfita21=fita21(1,size(fita21,2))-fita21(1,1);
        end
      </code></pre>
    </article>
    <p>Página 24</p>
    <article class="code24">
      <pre><code class="language-matlab">
        %% Dwell
        dfita1=dsta/rota(1,size(rota,2));
        dfita2=dsta/rota21(1,size(rota21,2));
        fifim=dfi*2+2*dfita+2*dfita21;
        p=1;
        while fifim>p*2*pi
        p=p+1;
        end
        dif=p*2*pi-fifim;
        difpadrao=2*pi/n1;
        if dif-difpadrao>=0
        fidwell=dif-difpadrao;
        else
        fidwell=dif+difpadrao;
        end
        fidwell1=fidwell*rota(1,size(rota,2))/(rota(1,size(rota,2))+rota21(1,size
        (rota21,2)));
        fidwell2=fidwell*rota21(1,size(rota21,2))/(rota(1,size(rota,2))+rota21(1,size
        (rota21,2)));
        alfata(1,n)=pi/2;
        while fita(1,n)< fitameio+fidwell1
        n=n+1;
        fita(1,n)=fita(1,n-1)+dfita1;
        lfta(1,n)=lfta(1,n-1)+rc*dfita1;
        alfata(1,n)=alfata(1,n-1);
        dalfadrota(1,n)=dalfadrota(1,n-1);
        rota(1,n)=rota(1,n-1);
        zta(1,n)=zta(1,n-1);
        end
        fita(1,n)=fita(1,nmeio)+fidwell1;
        lfta(1,n)=lfta(1,n-1)+rc*(fita(1,n)-fita(1,n-1));
        nfimrest=n;
        %% Segunda metade
        parte2turnaround='simetrico'
        switch lower(parte2turnaround)
        case {'integral'}
        case {'simetrico'}
        for i=0:nmeio-1

      </code></pre>
    </article>
    <p>Página 25</p>
    <article class="code25">
      <pre><code class="language-matlab">
        n=n+1;
        fita(1,nfimrest+i)=fita(1,nfimrest)+fita(1,nmeio)-fita(1,nmeio-i);
        lfta(1,nfimrest+i)=lfta(1,nfimrest)+lfta(1,nmeio)-lfta(1,nmeio-i);
        alfata(1,nfimrest+i)=alfata(1,nmeio)+(alfata(1,nmeio)-alfata(1,
        nmeio-i));
        rota(1,nfimrest+i)=rota(1,nmeio-i);
        zta(1,nfimrest+i)=zta(1,nmeio-i);
        dalfadrota(1,nfimrest+i)=-dalfadrota(1,nmeio-i);
        end
        n=n-1;
        end
        nfinal=n;
        alfafinal=alfata(1,n);
        fitafinal=fita(1,n);
        % Cartesianas
        xta=rota.*cos(fita);
        yta=rota.*sin(fita);
        end
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %--------------------------------------------------
        Trajectória2------------------------------------------------
        %% Trajectória da zona útil 2
        if rim==rfm
        traj2='cilindro simetrico'
        else
        traj2='cone simetrico'
        end
        switch lower(traj2)

      </code></pre>
    </article>
    <p>Página 26</p>
    <article class="code26">
      <pre><code class="language-matlab">
        case {'cone analitica'} %descontinuidade no inicio
        %% Trajectoria geodésica para cones - Koussios
        c1=sin(pi-alfai)*ri; %ver qual o angulo que deve estar aqui
        z2=[];
        fi2=[];
        fi21=[];
        ro2=[];
        alfa2=[];
        alfa21=[];
        dalfadro2=[];
        lf2=[];
        alfa2(1,1)=alfata(1,size(alfata,2));
        alfa21(1,1)=alfa2(1,1);
        dalfadro2(1,1)=dalfadrota(1,size(dalfadrota,2));
        dalfadro2(1,2)=dalfadro2(1,1);
        z2(1,1)=zfg;
        ro2(1,1)=((z2(1,1)*dm/lm)+rim-(dm*zim/lm));
        fi21(1,1)=0;
        lf2(1,1)=lfta(1,size(lfta,2));
        i=1;
        while z2(1,i)>zig
        i=i+1;
        z2(1,i)=z2(1,i-1)-ds*cos(alfa21(1,i-1))*cos(tau);
        ro2(1,i)=((z2(1,i)*dm/lm)+rim-(dm*zim/lm));
        fi21(1,i)=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro2(1,i))); %fazer contas
        para fazer fi ir aumentando
        alfa21(1,i)=atan((ro2(1,i)*(fi21(1,i)-fi21(1,i-1)))/((z2(1,i)-z2(1,i-1))
        /cos(tau)));
        alfa21(1,i)=alfa21(1,i)+pi;
        dalfadro2(1,i)=(alfa21(1,i)-alfa21(1,i-1))/(ro2(1,i)-ro2(1,i-1));
        lf2(1,i)=lf2(1,i-1)+ds;
        end
        if z2(1,i)~=zig
        z2(1,i)=zig;
        ro2(1,i)=((z2(1,i)*dm/lm)+rim-(dm*zim/lm));
        fi21(1,i)=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro2(1,i)));
        alfa21(1,i)=atan((ro2(1,i)*(fi21(1,i)-fi21(1,i-1)))/((z2(1,i)-z2(1,i-1))
        /cos(tau)));
        alfa21(1,i)=alfa21(1,i)+pi;
        dalfadro2(1,i)=(alfa21(1,i)-alfa21(1,i-1))/(ro2(1,i)-ro2(1,i-1));
        lf2(1,i)=lf2(1,i-1)+(z2(1,i)-z2(1,i-1))/(cos(tau)*cos(alfa21(1,i-1)));
        end
        alfa2=zeros(1,size(alfa21,2));
        i=i+1;

      </code></pre>
    </article>
    <p>Página 27</p>
    <article class="code27">
      <pre><code class="language-matlab">
        %passo extra
        z2pe=z2(1,i-1)-0.00001*cos(alfa21(1,i-1))*cos(tau);
        ro2pe=((z2pe*dm/lm)+rim-(dm*zim/lm));
        fi21pe=(1/sin(tau))*(asin(c1/rfg)-asin(c1/ro2pe));
        alfa21(1,i)=atan((ro2pe*(fi21pe-fi21(1,i-1)))/((z2pe-z2(1,i-1))/cos
        (tau)));
        alfa21(1,i)=alfa21(1,i)+pi;
        for j=1:size(alfa2,2)
        alfa2(1,i)=alfa21(1,i+1);
        end
        fi2=-fi21+fita(1,size(fita,2));
        %Cartesianas
        x2=ro2.*cos(fi2);
        y2=ro2.*sin(fi2);
        case {'cone simetrico'}
        fi2=[];
        lf2=[];
        alfa2=[];
        dalfadro2=[];
        ro2=[];
        z2=[];
        n=size(z,2);
        for i=1:size(z,2)
        z2(1,i)=z(1,n);
        ro2(1,i)=ro(1,n);
        dalfadro2(1,i)=-dalfadro(1,n);
        if alfai>0
        alfa2(1,i)=pi-alfa(1,n);
        else
        alfa2(1,i)=-pi-alfa(1,n);
        end
        fi2(1,i)=fita(1,size(fita,2))+fi(1,size(fi,2))-fi(1,n);
        lf2(1,i)=lfta(1,size(lfta,2))+lf(1,size(lf,2))-lf(1,n);
        n=n-1;
        end
        alfa2(1,1)=alfata(1,size(alfata,2));
        %% Cartesianas
        x2=ro2.*cos(fi2);
        y2=ro2.*sin(fi2);
        case {'cones integral'} %coordenadas polares
        %% Cálculos iniciais
        fi2=[];

      </code></pre>
    </article>
    <p>Página 28</p>
    <article class="code28">
      <pre><code class="language-matlab">
        lf2=[];
        alfa2=[];
        dalfadro2=[];
        ro2=[];
        z2=[];
        z2(1,1)=zfg;
        ro2(1,1)=rfg;
        if alfai>0
        alfa2(1,1)=pi-alfa(1,size(alfa,2));
        else
        alfa2(1,1)=-pi-alfa(1,size(alfa,2));
        end
        fi2(1,1)=fita(1,size(fita,2));
        lf2(1,1)=lfta(1,size(lfta,2));
        n=1;
        %% Cálculo de fi, alfa e Lf
        while z2(1,n)< zfg
        ro2(1,n+1)=ro2(1,n)+ds*cos(alfa2(1,n))*sin(tau);
        z2(1,n+1)=ro2(1,n+1).*lm/dm-rim*lm/dm+zim;
        dalfadro0=-0.5*ero*tan(alfa2(1,n))/gg1(1,1);
        dalfadro1=-0.5*ero*tan(alfa2(1,n))/gg1(1,1);
        dalfadro0=double(subs(dalfadro0,'ro',ro2(1,n)));
        dalfadro1=double(subs(dalfadro1,'ro',ro2(1,n+1)));
        dalfadro2(1,n)=dalfadro0;
        alfa2(1,n+1)=alfa2(1,n)+(ro2(1,n+1)-ro2(1,n))*(dalfadro0+dalfadro1)/2;
        E1=vpa(subs(gg1(1,1),'ro',ro2(1,n)));
        E1=vpa(subs(E1,'fi',fi2(1,n)));
        G1=vpa(subs(gg1(2,2),'ro',ro2(1,n)));
        G1=vpa(subs(G1,'fi',fi2(1,n)));
        E2=vpa(subs(gg1(1,1),'ro',ro2(1,n+1)));
        E2=vpa(subs(E1,'fi',fi2(1,n)));
        G2=vpa(subs(gg1(2,2),'ro',ro2(1,n+1)));
        G2=vpa(subs(G1,'fi',fi2(1,n)));
        n=n+1;
        fi2(1,n)=fi2(1,n-1)+0.5*(ro2(1,n)-ro2(1,n-1))*(tan(alfa2(1,n-1))*sqrt
        (G1/E1)+tan(alfa2(1,n))*sqrt(G2/E2)); %verificar contas
        lf2(1,n)=lf2(1,n-1)+0.5*(ro2(1,n)-ro2(1,n-1))*(sqrt(G1)/cos(alfa2(1,n-1))
        +sqrt(G2)/cos(alfa2(1,n))); %verificar contas
        end

      </code></pre>
    </article>
    <p>Página 29</p>
    <article class="code29">
      <pre><code class="language-matlab">
        if z2(1,n)~=zig
        z2(1,n+1)=zig;
        ro2(1,n+1)=((z2(1,n+1)*dm/lm)+rim-(dm*zim/lm));
        dalfadro0=0.5*ero*tan(alfa2(1,n))/gg1(1,1);
        dalfadro1=0.5*ero*tan(alfa2(1,n))/gg1(1,1);
        dalfadro0=double(subs(dalfadro0,'ro',ro2(1,n)));
        dalfadro1=double(subs(dalfadro1,'ro',ro2(1,n+1)));
        dalfadro2(1,n)=dalfadro0;
        alfa2(1,n+1)=alfa2(1,n)+(ro2(1,n+1)-ro2(1,n))*(dalfadro0+dalfadro1)/2;
        E1=vpa(subs(gg1(1,1),'ro',ro2(1,n)));
        E1=vpa(subs(E1,'fi',fi2(1,n)));
        G1=vpa(subs(gg1(2,2),'ro',ro2(1,n)));
        G1=vpa(subs(G1,'fi',fi2(1,n)));
        E2=vpa(subs(gg1(1,1),'ro',ro2(1,n+1)));
        E2=vpa(subs(E1,'fi',fi2(1,n)));
        G2=vpa(subs(gg1(2,2),'ro',ro2(1,n+1)));
        G2=vpa(subs(G1,'fi',fi2(1,n)));
        n=n+1;
        fi2(1,n)=fi2(1,n-1)+0.5*(ro2(1,n)-ro2(1,n-1))*(tan(alfa2(1,n-1))*sqrt
        (G1/E1)+tan(alfa2(1,n))*sqrt(G2/E2)); %verificar contas
        lf2(1,n)=lf2(1,n-1)+0.5*(ro2(1,n)-ro2(1,n-1))*(sqrt(G1)/cos(alfa2(1,n-1))
        +sqrt(G2)/cos(alfa2(1,n))); %verificar contas
        end
        %% Cartesianas
        x2=ro2.*cos(fi2);
        y2=ro2.*sin(fi2);
        case {'cilindro analitica'}
        %% Trajectória geodésica para cilindros - hélices
        % Helice
        dz2=ds*cos(pi-alfai);
        z2=[];
        z2(1,:)=zfg:dz2:zig;
        if z2(1,size(z2,2))~=zig
        z2(1,size(z2,2)+1)=zig;
        end
        c2=rc/tan(pi-alfai);
        fi21=z2/c2;
        fi2=fita(1,size(fita,2))+fi21-fi21(1,1);
        x2=rc*cos(fi2);
        y2=rc*sin(fi2);

      </code></pre>
    </article>
    <p>Página 30</p>
    <article class="code30">
      <pre><code class="language-matlab">
        %para dar continuidade estes dados são necessários no TA
        alfa2=ones(1,size(x2,2)).*(pi-alfai);
        lf2=sqrt(((fi2-fita(1,size(fita,2))).*rc).^2+(zta(1,size(zta,2))-z2).^2)+lfta
        (1,size(lfta,2));
        tetai2=pi-tetai;
        tetaf2=tetai;
        dalfadteta2=zeros(1,size(x2,2));
        teta2=atan(rc./(zeroteta-z2));
        tetap2=[];
        tetap2(1,1)=teta2(1,1);
        for n=1:size(teta2,2)
        if teta2(1,n)< 0
        tetap2(1,n)=teta2(1,n)+pi;
        else
        tetap2(1,n)=teta2(1,n);
        end
        end
        case {'cilindro simetrico'} %
        fi2=[];
        lf2=[];
        alfa2=[];
        dalfadteta2=[];
        z2=[];
        tetap2=[];
        teta2=[];
        n=size(z,2);
        for i=1:size(z,2)
        z2(1,i)=z(1,n);
        tetap2(1,i)=tetap(1,n);
        teta2(1,i)=teta(1,n);
        dalfadteta2(1,i)=-dalfadteta(1,n);
        if alfai>0
        alfa2(1,i)=pi-alfa(1,n);
        else
        alfa2(1,i)=-pi-alfa(1,n);
        end
        fi2(1,i)=fita(1,size(fita,2))+fi(1,size(fi,2))-fi(1,n);
        lf2(1,i)=lfta(1,size(lfta,2))+lf(1,size(lf,2))-lf(1,n);
        n=n-1;
        end
        alfa2(1,1)=alfata(1,size(alfata,2));
        %% Cartesianas

      </code></pre>
    </article>
    <p>Página 31</p>
    <article class="code31">
      <pre><code class="language-matlab">
        x2=rc*cos(fi2);
        y2=rc*sin(fi2);
        tetaf2=tetai;
        case {'cilindro esfericas'} %integrar coordenadas esfericas
        %% Cálculos iniciais
        tetai2=pi-tetai;
        tetaf2=tetai;
        fi2=[];
        lf2=[];
        alfa2=[];
        dalfadteta2=[];
        alfa2(1,1)=alfata(1,size(alfata,2));
        teta2=[];
        teta1=tetai2;
        teta2(1,1)=teta1;
        tetap2=[];
        tetap2(1,1)=tetai2;
        fi2(1,1)=fita(1,size(fita,2));
        lf2(1,1)=lfta(1,size(lfta,2));
        n=1;
        j=1;
        %% Cálculo de fi, alfa e Lf
        while tetap2(1,n)>tetaf2
        %Gerar teta para ds constante
        j=n+1;
        teta2(1,j)=teta1;
        teta3=atan(1/(-(ds*cos(alfa2(1,n)))/rc+1/tan(teta1)));
        teta1=teta3;
        if teta2(1,j)< 0
        tetap2(1,j)=teta2(1,j)+pi;
        else
        tetap2(1,j)=teta2(1,j);
        end
        dalfadteta0=0.5*eteta*tan(alfa2(1,n))/gg1(1,1);
        dalfadteta1=0.5*eteta*tan(alfa2(1,n))/gg1(1,1);
        dalfadteta0=double(subs(dalfadteta0,'teta',tetap2(1,n)));
        dalfadteta1=double(subs(dalfadteta1,'teta',tetap2(1,n+1)));
        dalfadteta2(1,n)=dalfadteta0;
        alfa2(1,n+1)=alfa2(1,n)+(tetap2(1,n+1)-tetap2(1,n))*

      </code></pre>
    </article>
    <p>Página 32</p>
    <article class="code32">
      <pre><code class="language-matlab">
        (dalfadteta0+dalfadteta1)/2;
        E1=vpa(subs(gg1(1,1),'teta',tetap2(1,n)));
        E1=vpa(subs(E1,'fi',fi2(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetap2(1,n)));
        G1=vpa(subs(G1,'fi',fi2(1,n)));
        E2=vpa(subs(gg1(1,1),'teta',tetap2(1,n+1)));
        E2=vpa(subs(E1,'fi',fi2(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetap2(1,n+1)));
        G2=vpa(subs(G1,'fi',fi2(1,n)));
        n=n+1;
        fi2(1,n)=fi2(1,n-1)+0.5*(tetap2(1,n)-tetap2(1,n-1))*(tan(alfa2(1,n-1))*sqrt
        (G1/E1)+tan(alfa2(1,n))*sqrt(G2/E2));
        lf2(1,n)=lf2(1,n-1)+0.5*(tetap2(1,n)-tetap2(1,n-1))*(sqrt(G1)/cos(alfa2(1,
        n-1))+sqrt(G2)/cos(alfa2(1,n)));
        end
        if tetap2(1,n-1)~=tetaf2
        tetap2(1,n)=tetaf2;
        dalfadteta0=0.5*eteta*tan(alfa2(1,n))/gg1(1,1);
        dalfadteta1=0.5*eteta*tan(alfa2(1,n))/gg1(1,1);
        dalfadteta0=double(subs(dalfadteta0,'teta',tetap2(1,n)));
        dalfadteta1=double(subs(dalfadteta1,'teta',tetap2(1,n+1)));
        dalfadteta2(1,n)=dalfadteta0;
        alfa2(1,n+1)=alfa2(1,n)+(tetap2(1,n+1)-tetap2(1,n))*
        (dalfadteta0+dalfadteta1)/2;
        E1=vpa(subs(gg1(1,1),'teta',tetap2(1,n)));
        E1=vpa(subs(E1,'fi',fi2(1,n)));
        G1=vpa(subs(gg1(2,2),'teta',tetap2(1,n)));
        G1=vpa(subs(G1,'fi',fi2(1,n)));
        E2=vpa(subs(gg1(1,1),'teta',tetap2(1,n+1)));
        E2=vpa(subs(E1,'fi',fi2(1,n)));
        G2=vpa(subs(gg1(2,2),'teta',tetap2(1,n+1)));
        G2=vpa(subs(G1,'fi',fi2(1,n)));
        n=n+1;
        fi2(1,n)=fi2(1,n-1)+0.5*(tetap2(1,n)-tetap2(1,n-1))*(tan(alfa2(1,n-1))*sqrt
        (G1/E1)+tan(alfa2(1,n))*sqrt(G2/E2));
        lf2(1,n)=lf2(1,n-1)+0.5*(tetap2(1,n)-tetap2(1,n-1))*(sqrt(G1)/cos(alfa2(1,
        n-1))+sqrt(G2)/cos(alfa2(1,n)));
        end
        %% Cartesianas

      </code></pre>
    </article>
    <p>Página 33</p>
    <article class="code33">
      <pre><code class="language-matlab">
        ro2=rc./sin(tetap2);
        x2=ro2.*sin(tetap2).*cos(fi2);
        y2=ro2.*sin(tetap2).*sin(fi2);
        z2=-ro2.*cos(tetap2)+zeroteta;
        end
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %
        --------------------------------------------------------------------------------------
        ------------------------
        %---------------------------------------------------
        Turnaround2------------------------------------------------
        %% Turnaround 2
        if rim==rfm
        turnaround2='cilindro'
        else
        turnaround2='cone'
        end
        switch lower(turnaround2)
        case {'cone'}
        zta2=[];
        fita2=[];
        rota2=[];
        alfata2=[];
        lfta2=[];
        dalfadrota2=[];
        zta2(1,:)=zta21(1,:);
        fita2(1,:)=fi2(1,size(fi2,2))+fita21(1,:);
        rota2(1,:)=rota21(1,:);
        alfata2(1,:)=alfa2(1,size(alfa2,2))-abs(-alfata21(1,:)+alfata21(1,1));
        alfata2(1,size(alfata21,2))=pi/2;
        lfta2(1,:)=lf2(1,size(lf2,2))-lfta21(1,:);
        dalfadrota2(1,:)=dalfadrota21(1,:);
        fitameio2=fita21(1,size(fita21,2))+fi2(1,size(fi2,2));
        n=size(fita21,2);

      </code></pre>
    </article>
    <p>Página 34</p>
    <article class="code34">
      <pre><code class="language-matlab">
        %Dwell2
        while fita2(1,n)< fitameio2+fidwell2
        n=n+1;
        fita2(1,n)=fita2(1,n-1)+dfita2;
        lfta2(1,n)=lfta2(1,n-1)+rc*dfita2;
        alfata2(1,n)=alfata2(1,n-1);
        dalfadrota2(1,n)=dalfadrota2(1,n-1);
        rota2(1,n)=rota2(1,n-1);
        zta2(1,n)=zta2(1,n-1);
        end
        fita2(1,n)=fita2(1,nmeio2)+fidwell2;
        lfta2(1,n)=lfta2(1,n-1)+rc*(fita2(1,n)-fita2(1,n-1));
        nfimrest2=n;
        for i=0:nmeio2-1
        n=n+1;
        fita2(1,nfimrest2+i)=fita2(1,nfimrest2)+fita2(1,nmeio2)-fita2(1,nmeio2-
        i);
        lfta2(1,nfimrest2+i)=lfta2(1,nfimrest2)+lfta2(1,nmeio2)-lfta2(1,nmeio2-
        i);
        if alfai>0
        alfata2(1,nfimrest2+i)=pi/2-(alfata2(1,nmeio2-i)-pi/2);
        else
        alfata2(1,nfimrest2+i)=-pi/2+(-alfata2(1,nmeio2-i)-pi/2);
        end
        rota2(1,nfimrest2+i)=rota2(1,nmeio2-i);
        zta2(1,nfimrest2+i)=zta2(1,nmeio2-i);
        dalfadrota2(1,nfimrest2+i)=-dalfadrota2(1,nmeio2-i);
        end
        n=n-1;
        %% Cartesianas
        xta2=rota2.*cos(fita2);
        yta2=rota2.*sin(fita2);
        case {'cilindro'}
        %% Cálculos iniciais
        alfaita2=alfa2(1,size(alfa2,2));
        teta1=tetaf2;
        tetata2=[];
        tetata2(1,1)=teta1;
        tetatap2=[];
        tetatap2(1,1)=teta1;
        alfata2=[];
        alfata2(1,1)=alfaita2;

      </code></pre>
    </article>
    <p>Página 35</p>
    <article class="code35">
      <pre><code class="language-matlab">
        fita2=[];
        fita2(1,1)=fi2(1,size(fi2,2));
        lfta2=[];
        lfta2(1,1)=lf2(1,size(lf2,2));
        dalfadtetata2=[];
        dalfadtetata2(1,1)=dalfadteta2(1,size(dalfadteta2,2));
        n=1;
        %% Primeira metade
        for i=2:nmeio
        n=n+1;
        fita2(1,i)=fita2(1,1)+fita(1,i)-fita(1,1);
        lfta2(1,i)=lfta2(1,1)+lfta(1,i)-lfta(1,1);
        alfata2(1,i)=pi-alfata(1,i);
        tetatap2(1,i)=tetatap2(1,1)-tetatap(1,i)+tetatap(1,1);
        tetata2(1,i)=tetatap2(1,i);
        dalfadtetata2(1,i)=-dalfadtetata(1,i);
        end
        %% Dwell
        nmeio2=n;
        alfatameio2=alfata2(1,n);
        fitameio2=fita2(1,n);
        dfita=dsta/rc;
        while fita2(1,n)< fitameio2+fidwell
        n=n+1;
        fita2(1,n)=fita2(1,n-1)+dfita;
        lfta2(1,n)=lfta2(1,n-1)+rc*dfita;
        alfata2(1,n)=alfata2(1,n-1);
        dalfadtetata2(1,n)=dalfadtetata2(1,n-1);
        tetata2(1,n)=tetata2(1,n-1);
        tetatap2(1,n)=tetatap2(1,n-1);
        end
        fita2(1,n)=fita2(1,nmeio2)+fidwell;
        lfta2(1,n)=lfta2(1,n-1)+rc*(fita2(1,n)-fita2(1,n-1));
        nfimrest2=n;
        %% Segunda metade
        for i=0:nmeio2-1
        n=n+1;
        fita2(1,nfimrest2+i)=fita2(1,nfimrest2)+fita2(1,nmeio2)-fita2(1,nmeio2-i);

      </code></pre>
    </article>
    <p>Página 36</p>
    <article class="code36">
      <pre><code class="language-matlab">
        lfta2(1,nfimrest2+i)=lfta2(1,nfimrest2)+lfta2(1,nmeio2)-lfta2(1,nmeio2-i);
        alfata2(1,nfimrest2+i)=pi-alfata2(1,nmeio2-i);
        tetatap2(1,nfimrest2+i)=tetatap2(1,nmeio2-i);
        tetata2(1,nfimrest2+i)=tetatap2(1,nmeio2-i);
        dalfadtetata2(1,nfimrest2+i)=-dalfadtetata2(1,nmeio2-i);
        end
        n=n-1;
        % Cartesianas
        rota2=rc./sin(tetatap2);
        xta2=rota2.*sin(tetatap2).*cos(fita2);
        yta2=rota2.*sin(tetatap2).*sin(fita2);
        zta2=-rota2.*cos(tetatap2)+zeroteta;
        zta2(1,1)=z2(1,size(z2,2));
        zta2(1,size(zta2,2))=zig;
        end
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %% Ciclo
        ficiclo=[];
        zciclo=[];
        alfaciclo=[];
        rociclo=[];
        lfciclo=[];
        ficiclo(1,:)=[fi fita fi2 fita2];
        alfaciclo(1,:)=[alfa alfata alfa2 alfata2];
        lfciclo(1,:)=[lf lfta lf2 lfta2];
        if rim==rfm
        tetaciclo=[];
        dalfadtetaciclo=[];
        tetaciclo(1,:)=[tetap tetatap tetap2 tetatap2];
        dalfadtetaciclo(1,:)=[dalfadteta dalfadtetata dalfadteta2 dalfadtetata2];
        rociclo=ones(1,size(tetaciclo,2))*rc;
      </code></pre>
    </article>
    <p>Página 37</p>
    <article class="code37">
      <pre><code class="language-matlab">
        else
        dalfadrociclo=[];
        rociclo=[ro rota ro2 rota2];
        dalfadrociclo=[dalfadro dalfadrota dalfadro2 dalfadrota2];
        end
        % Cartesianas
        xciclo=[x xta x2 xta2];
        yciclo=[y yta y2 yta2];
        zciclo=[z zta z2 zta2];
        %% Espessura média por volume de secções
        %Espessura média da zona útil
        lfzu1c=lf(1,size(lf,2))+lf2(1,size(lf2,2))-lf2(1,1);
        lfzu=lfzu1c*n1;
        vfibra=b*lfzu*esp;
        zutil=lg;
        h1=zfg-(-rim*lm/dm+zim);
        if rim==rfm
        dr=((vfibra/(pi*zutil)+rig^2)^0.5)-rig;
        else
        dr=((pi*rfg^4 + pi*rig^4 + 24*rfg*vfibra*tan(tau) - 24*rig*vfibra*tan(tau) -
        2*pi*rfg^2*rig^2 + 12*vfibra*zutil*tan(tau)^2 + 4*pi*h1^2*rfg^2*tan(tau)^2 +
        4*pi*h1^2*rig^2*tan(tau)^2 + 4*pi*rig^2*zutil^2*tan(tau)^2 + 4*pi*h1*rfg^3*tan(tau) +
        4*pi*h1*rig^3*tan(tau) - 4*pi*rig^3*zutil*tan(tau) - 4*pi*h1*rfg*rig^2*tan(tau) -
        4*pi*h1*rfg^2*rig*tan(tau) + 4*pi*rfg^2*rig*zutil*tan(tau) - 8*pi*h1^2*rfg*rig*tan
        (tau)^2 - 8*pi*h1*rig^2*zutil*tan(tau)^2 + 8*pi*h1*rfg*rig*zutil*tan(tau)^2)^(1/2) -
        pi^(1/2)*rfg^2 + pi^(1/2)*rig^2 - 2*pi^(1/2)*h1*rfg*tan(tau) + 2*pi^(1/2)*h1*rig*tan
        (tau) - 2*pi^(1/2)*rig*zutil*tan(tau))/(pi^(1/2)*(4*rfg - 4*rig + 2*zutil*tan(tau)));
        end
        espmedia=dr*cos(tau);
        %Espessura média por secções ao longo do mandril
        [zmax,imax]=max(zciclo(:));
        [zmin,imin]=min(zciclo(:));
        lrta1=lfta(nfimrest)-lfta(nmeio);
        lrta2=lfta2(nfimrest2)-lfta2(nmeio2);
        espmed='z';
        switch (espmed)
        case {'i'}
        %variando i
        zl=zmin;
        e=2;
        lfesp=[];
        ze=[];
        ze1=[];

      </code></pre>
    </article>
    <p>Página 38</p>
    <article class="code38">
      <pre><code class="language-matlab">
        ze2=[];
        lfesp(1,1)=lrta2;
        ze(1,1)=zmin;
        ze1(1,1)=zmin;
        ze2(1,1)=zmin;
        for i=(size(z2,2)+size(z,2)+size(zta,2)+nmeio):-5:(size(z,2)+nfimrest)
        lfesp1=lfciclo(1,i);
        lfesp2=lfciclo(1,i-5);
        lfesp(1,e)=2*abs(lfesp1-lfesp2);
        ze1(1,e)=zciclo(1,i);
        ze2(1,e)=zciclo(1,i-5);
        ze(1,e)=(ze1(1,e)+ze2(1,e))/2;
        e=e+1;
        end
        lfesp(1,e)=lrta1;
        ze1(1,e)=zmax;
        ze2(1,e)=zmax;
        ze(1,e)=zmax;
        lfespt=lfesp.*n1;
        espsec=zeros(1,size(lfesp,2));
        for e=1:size(lfesp,2)
        %para cones - rfg e rig sao ro1 e ro2
        zutil=abs(ze2(1,e)-ze1(1,e));
        h1=ze2(1,e)-(-rim*lm/dm+zim);
        vfibra=b*lfespt(1,e)*esp;
        if rim==rfm
        dr=((vfibra/(pi*zutil)+rig^2)^0.5)-rig;
        else
        dr=((pi*rfg^4 + pi*rig^4 + 24*rfg*vfibra*tan(tau) - 24*rig*vfibra*tan
        (tau) - 2*pi*rfg^2*rig^2 + 12*vfibra*zutil*tan(tau)^2 + 4*pi*h1^2*rfg^2*tan(tau)^2 +
        4*pi*h1^2*rig^2*tan(tau)^2 + 4*pi*rig^2*zutil^2*tan(tau)^2 + 4*pi*h1*rfg^3*tan(tau) +
        4*pi*h1*rig^3*tan(tau) - 4*pi*rig^3*zutil*tan(tau) - 4*pi*h1*rfg*rig^2*tan(tau) -
        4*pi*h1*rfg^2*rig*tan(tau) + 4*pi*rfg^2*rig*zutil*tan(tau) - 8*pi*h1^2*rfg*rig*tan
        (tau)^2 - 8*pi*h1*rig^2*zutil*tan(tau)^2 + 8*pi*h1*rfg*rig*zutil*tan(tau)^2)^(1/2) -
        pi^(1/2)*rfg^2 + pi^(1/2)*rig^2 - 2*pi^(1/2)*h1*rfg*tan(tau) + 2*pi^(1/2)*h1*rig*tan
        (tau) - 2*pi^(1/2)*rig*zutil*tan(tau))/(pi^(1/2)*(4*rfg - 4*rig + 2*zutil*tan(tau)));
        end
        espsec(1,e)=dr*cos(tau);
        end
        figure (7)
        plot(ze,espsec)
        title('ze espsex')
        xlabel('z')
        ylabel('Espessura')
        figure (8)
        plot(ze,lfesp)
        title('ze,lfesp')
        xlabel('z')
        ylabel('Lf')

      </code></pre>
    </article>
    <p>Página 39</p>
    <article class="code39">
      <pre><code class="language-matlab">
        case {'z'}
        %Variando z
        c=imin;
        zcena=zciclo(1,c);
        c2=1;
        for i=zmin:5:zmax
        p=0;
        zcena1=zcena;
        while zcena< i
        c=c-1;
        zcena=zciclo(1,c);
        p=p+1;
        end
        deltaz=abs(zcena-zcena1);
        lfespz(1,c2)=2*abs(lfciclo(1,c)-lfciclo(1,c+p));
        zespz(1,c2)=zciclo(1,c);
        c2=c2+1;
        end
        lfesptz=lfespz.*n1;
        espsecz=zeros(1,size(lfespz,2));
        for e=1:size(lfespz,2)-1
        %para cones - rfg e rig sao ro1 e ro2
        zutil=abs(zespz(1,e)-zespz(1,e+1));
        h1=zespz(1,e+1)-(-rim*lm/dm+zim);
        vfibra=b*lfesptz(1,e)*esp;
        if rim==rfm
        dr=((vfibra./(pi*zutil)+rig^2)^0.5)-rig;
        else
        dr=((pi*rfg^4 + pi*rig^4 + 24*rfg*vfibra*tan(tau) - 24*rig*vfibra*tan
        (tau) - 2*pi*rfg^2*rig^2 + 12*vfibra*zutil*tan(tau)^2 + 4*pi*h1^2*rfg^2*tan(tau)^2 +
        4*pi*h1^2*rig^2*tan(tau)^2 + 4*pi*rig^2*zutil^2*tan(tau)^2 + 4*pi*h1*rfg^3*tan(tau) +
        4*pi*h1*rig^3*tan(tau) - 4*pi*rig^3*zutil*tan(tau) - 4*pi*h1*rfg*rig^2*tan(tau) -
        4*pi*h1*rfg^2*rig*tan(tau) + 4*pi*rfg^2*rig*zutil*tan(tau) - 8*pi*h1^2*rfg*rig*tan
        (tau)^2 - 8*pi*h1*rig^2*zutil*tan(tau)^2 + 8*pi*h1*rfg*rig*zutil*tan(tau)^2)^(1/2) -
        pi^(1/2)*rfg^2 + pi^(1/2)*rig^2 - 2*pi^(1/2)*h1*rfg*tan(tau) + 2*pi^(1/2)*h1*rig*tan
        (tau) - 2*pi^(1/2)*rig*zutil*tan(tau))/(pi^(1/2)*(4*rfg - 4*rig + 2*zutil*tan(tau)));
        end
        espsecz(1,e)=dr*cos(tau);
        end
        %figure (7)
        %plot(zespz,lfespz)
        %title('zespz,lfespz')
        %xlabel('z')
        %ylabel('Lf')
        %figure (8)
        %plot(zespz(1,1:size(zespz,2)),espsecz)
        %title('zespz,espsecz')
        %xlabel('z')

      </code></pre>
    </article>
    <p>Página 40</p>
    <article class="code40">
      <pre><code class="language-matlab">
        %ylabel('Espessura')
        end
        %% Restantes Paths - NP
        switch (lower(seccoes))
        case {'rectangular'}
        dfilargura(1,:)=(b./(2.*rociclo(1,:))).*(cos(alfaciclo(1,:)));
        %dfilargura=[dfilargura1(1,1:(size(z,2)+nfimrest-1)) -dfilargura1(1,(size(z,2)
        +nfimrest):(size(z,2)+size(zta,2)+size(z2,2)+nfimrest2-1)) dfilargura1(1,(size(z,2)
        +size(zta,2)+size(z2,2)+nfimrest2):size(dfilargura1,2))];
        dzlargura(1,:)=(b/2).*sin(alfaciclo(1,:)).*cos(tau);
        %dzlargura=[dzlargura1(1,1:(size(z,2)+nfimrest-1)) -dzlargura1(1,(size(z,2)+nfimrest):
        (size(z,2)+size(zta,2)+size(z2,2)+nfimrest2-1)) dzlargura1(1,(size(z,2)+size(zta,2)
        +size(z2,2)+nfimrest2):size(dzlargura1,2))];
        ficiclola=zeros(2*NP+1,size(ficiclo,2));
        zciclola=zeros(4*NP+2,size(ficiclola,2));
        rociclola=zeros(2*NP+1,size(ficiclo,2));
        for i=1:(2*NP+1)
        ficiclola(i,:)=ficiclo(1,:)-dfilargura(1,:)+(i-1)*(dfilargura(1,:)/NP);
        zciclola(i,:)=zciclo(1,:)+dzlargura(1,:)-(i-1)*(dzlargura(1,:)/NP);
        rociclola(i,:)=((zciclola(i,:)*dm/lm)+rim-(dm*zim/lm));
        end
        % Cartesianas multiplas linhas
        xciclola=zeros(4*NP+2,size(ficiclola,2));
        yciclola=zeros(4*NP+2,size(ficiclola,2));
        for n=1:2*NP+1
        xciclola(n,:)=rociclola(n,:).*cos(ficiclola(n,:));
        yciclola(n,:)=rociclola(n,:).*sin(ficiclola(n,:));
        end
        c=1;
        for n=2*NP+2:2*(2*NP+1)
        xciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*cos(ficiclola((2*NP+2-
        c),:));
        yciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*sin(ficiclola((2*NP+2-
        c),:));
        zciclola(n,:)=zciclola((2*NP+2-c),:)-esp*sin(tau);
        c=c+1;
        end
        case {'lenticular'} %necessário dar espessura
        case {'eliptical'} %necessário dar espessura (belip) - meia elipse
        aelip=b/2;
        dfilargura(1,:)=(b./(2.*rociclo(1,:))).*(cos(alfaciclo(1,:)));
        %dfilargura=[dfilargura1(1,1:(size(z,2)+nfimrest-1)) -dfilargura1(1,(size(z,2)
        +nfimrest):(size(z,2)+size(zta,2)+size(z2,2)+nfimrest2-1)) dfilargura1(1,(size(z,2)

      </code></pre>
    </article>
    <p>Página 41</p>
    <article class="code41">
      <pre><code class="language-matlab">
        +size(zta,2)+size(z2,2)+nfimrest2):size(dfilargura1,2))];
        dzlargura(1,:)=(b/2).*sin(alfaciclo(1,:)).*cos(tau);
        %dzlargura=[dzlargura1(1,1:(size(z,2)+nfimrest-1)) -dzlargura1(1,(size(z,2)+nfimrest):
        (size(z,2)+size(zta,2)+size(z2,2)+nfimrest2-1)) dzlargura1(1,(size(z,2)+size(zta,2)
        +size(z2,2)+nfimrest2):size(dzlargura1,2))];
        ficiclola=zeros(4*NP+2,size(ficiclo,2));
        zciclola=zeros(4*NP+2,size(ficiclola,2));
        rociclola=zeros(4*NP+2,size(ficiclo,2));
        xelip=zeros(4*NP+2,size(ficiclo,2));
        tetaelip=zeros(4*NP+2,size(ficiclo,2));
        yelip=zeros(4*NP+2,size(ficiclo,2));
        for i=1:(2*NP+1)
        ficiclola(i,:)=ficiclo(1,:)-dfilargura(1,:)+(i-1)*(dfilargura(1,:)/NP);
        zciclola(i,:)=zciclo(1,:)+dzlargura(1,:)-(i-1)*(dzlargura(1,:)/NP);
        rociclola(i,:)=((zciclola(i,:)*dm/lm)+rim-(dm*zim/lm));
        end
        for i=(2*NP+2):(4*NP+2)
        ficiclola(i,:)=ficiclo(1,:)-dfilargura(1,:)+(i-1)*(dfilargura(1,:)/NP);
        zciclola(i,:)=zciclo(1,:)+dzlargura(1,:)-(i-1)*(dzlargura(1,:)/NP);
        rociclola(i,:)=((zciclola(i,:)*dm/lm)+rim-(dm*zim/lm));
        xelip(i,:)=-aelip+(i-(2*NP+2))*aelip/NP;
        tetaelip(i,:)=acos(xelip(i,:)/aelip);
        yelip(i,:)=belip*sin(tetaelip(i,:));
        end
        % Cartesianas multiplas linhas
        xciclola=zeros(4*NP+2,size(ficiclola,2));
        yciclola=zeros(4*NP+2,size(ficiclola,2));
        for n=1:2*NP+1
        xciclola(n,:)=rociclola(n,:).*cos(ficiclola(n,:));
        yciclola(n,:)=rociclola(n,:).*sin(ficiclola(n,:));
        end
        c=1;
        for n=2*NP+2:2*(2*NP+1)
        xciclola(n,:)=(rociclola((2*NP+2-c),:)+yelip(n,:)/cos(tau)).*cos(ficiclola
        ((2*NP+2-c),:));
        yciclola(n,:)=(rociclola((2*NP+2-c),:)+yelip(n,:)/cos(tau)).*sin(ficiclola
        ((2*NP+2-c),:));
        zciclola(n,:)=zciclola((2*NP+2-c),:)-yelip(n,:)*sin(tau);
        c=c+1;
        end
        end
        %% Plot
        scrsz = get(0,'ScreenSize');
        x0=0; y0=0; width=scrsz(3); height=scrsz(4);
        posfig=[x0 y0 width height];
        %Mandril e trajectoria com multiplas linhas

      </code></pre>
    </article>
    <p>Página 42</p>
    <article class="code42">
      <pre><code class="language-matlab">
        figure ('Name','First cycle','NumberTitle','off','Position',posfig);
        %surf(Z,X,Y,'FaceColor','c','FaceAlpha',.
        7,'EdgeColor','none','LineStyle','none')
        %hold on;
        surf(zciclola(:,:),yciclola(:,:),xciclola
        (:,:),'FaceColor','r','EdgeColor','none','LineStyle','none')
        hold on;
        %plot3(zciclo(1,:),xciclo(1,:),yciclo(1,:),'r','Linewidth',2);
        plot3(zciclola(1,:),yciclola(1,:),xciclola(1,:),'k','Linewidth',0.5);
        plot3(zciclola(:,1),yciclola(:,1),xciclola(:,1),'k','Linewidth',0.5);
        plot3(zciclola(:,size(zciclola,2)),yciclola(:,size(zciclola,2)),xciclola(:,
        size(zciclola,2)),'k','Linewidth',0.5);
        plot3(zciclola((2*NP+1),:),yciclola((2*NP+1),:),xciclola
        ((2*NP+1),:),'k','Linewidth',0.5);
        plot3(zciclola((2*NP+2),:),yciclola((2*NP+2),:),xciclola
        ((2*NP+2),:),'k','Linewidth',0.5);
        plot3(zciclola(2*(2*NP+1),:),yciclola(2*(2*NP+1),:),xciclola(2*
        (2*NP+1),:),'k','Linewidth',0.5);
        plot3(zciclola((3*NP+2),:),yciclola((3*NP+2),:),xciclola
        ((3*NP+2),:),'b','Linewidth',0.5);
        axis equal
        plot3(z(1),y(1),x(1),'-go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .
        63],'MarkerSize',7)
        plot3(z(size(z,2)),y(size(y,2)),x(size(x,2)),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta(nmeio),yta(nmeio),xta(nmeio),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta(nfimrest),yta(nfimrest),xta(nfimrest),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta(size(zta,2)),yta(size(yta,2)),xta(size(xta,2)),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(z2(size(z2,2)),y2(size(y2,2)),x2(size(x2,2)),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta2(nmeio2),yta2(nmeio2),xta2(nmeio2),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta2(nfimrest2),yta2(nfimrest2),xta2(nfimrest2),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',5)
        plot3(zta2(size(zta2,2)),yta2(size(yta2,2)),xta2(size(xta2,2)),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',7)
        %title('Mandril e trajectória no mandril do primeiro ciclo')
        title('Graphic representation of the tow along the first cycle')
        xlabel('z / mm')
        ylabel('y / mm')
        zlabel('x / mm')
        set(gcf,'color','w');
        grid on;
        figure ('Name','Parameter variation along 1
        cycle','NumberTitle','off','Position',posfig);
        %Alfa em funcao de z
        subplot(2,2,1)
        plot(zciclo(1,:),alfaciclo(1,:))
      </code></pre>
    </article>
    <p>Página 43</p>
    <article class="code43">
      <pre><code class="language-matlab">
        title('Variation of \alpha related to z')
        xlabel('z / mm')
        ylabel('\alpha')
        set(gcf,'color','w');
        grid on;
        %set(gcf,'GridAlpha',0.12);
        if rim==rfm
        %dalfadteta em funcao de teta
        subplot(2,2,2)
        plot(tetaciclo(1,:),dalfadtetaciclo(1,:))
        title('Variation of d\alpha/d\theta related to the meridian \theta')
        xlabel('\theta')
        ylabel('d\alpha/d\theta')
        set(gcf,'color','w');
        grid on;
        %set(gcf,'GridAlpha',0.1);
        else
        %dalfadro em funcao de ro
        subplot(2,2,2)
        plot(rociclo(1,:),dalfadrociclo(1,:))
        title('Variation of d\alpha/d\rho related to the meridian \rho')
        xlabel('\rho / mm')
        ylabel('d\alpha/d\rho')
        set(gcf,'color','w');
        grid on;
        end
        %Phi em funcao de z
        subplot(2,2,3)
        plot(zciclo(1,:),ficiclo(1,:))
        title('Variation of \phi related to z')
        xlabel('z / mm')
        ylabel('\phi')
        set(gcf,'color','w');
        grid on;
        %set(gcf,'GridAlpha',0.07);
        %Comprimento da trajectoria (Lf) em funcao de z
        subplot(2,2,4)
        plot(zciclo(1,:),lfciclo(1,:))
        title('Variation of Lf related to z')
        xlabel('z / mm')
        ylabel('Lf / mm')
        set(gcf,'color','w');
        grid on;
        %set(gcf,'GridAlpha',0.05);
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %

      </code></pre>
    </article>
    <p>Página 44</p>
    <article class="code44">
      <pre><code class="language-matlab">
        %--------------------------------------------------------------------------------------
        -----------------------
        %
        --------------------------------------------------------------------------------------
        -----------------------
        %% Próximos ciclos
        %dficiclo=max(ficiclo(1,:))-(ceil(max(ficiclo(1,:))/(2*pi))*2*pi);
        figure ('Name','Fibre trajectories in the first layer','NumberTitle','off','Position',
        posfig);
        surf(Z,X,Y,'FaceColor','c','FaceAlpha',.7,'EdgeColor','none','LineStyle','none')
        hold on;
        plot3(zciclola(NP+1,:),yciclola(NP+1,:),xciclola(NP+1,:),'k');
        axis equal
        plot3(zciclola(NP+1,1),yciclola(NP+1,1),xciclola(NP+1,1),'-
        go','MarkerEdgeColor','k','MarkerFaceColor','k','MarkerSize',7)
        title('Trajectories in the first layer')
        xlabel('z /mm')
        ylabel('y /mm')
        zlabel('x /mm')
        set(gcf,'color','w');
        dficiclo=ficiclo(1,size(ficiclo,2));
        for i=2:n1
        ficiclo(i,:)=ficiclo(i-1,:)+dficiclo;
        rociclo(i,:)=rociclo(1,:);
        xciclo(i,:)=rociclo(1,:).*cos(ficiclo(i,:));
        yciclo(i,:)=rociclo(1,:).*sin(ficiclo(i,:));
        zciclo(i,:)=zciclo(1,:);
        %surf(zciclola,yciclola,
        xciclola,'FaceColor','r','EdgeColor','none','LineStyle','none')
        % plot3(zciclo2(i,:),yciclo2(i,:),xciclo2(i,:),'k','Linewidth',0.5);
        % plot3(zciclo3(i,:),yciclo3(i,:),xciclo3(i,:),'k','Linewidth',0.5);
        % plot3(zciclol(6,:),yciclol(6,:),xciclol(6,:),'k','Linewidth',0.5);
        % plot3(zciclol(4,:),yciclol(4,:),xciclol(4,:),'k','Linewidth',0.5);
        plot3(zciclo(i,:),yciclo(i,:),xciclo(i,:),'r')
        plot3(zciclo(i,1),yciclo(i,1),xciclo(i,1),'-
        go','MarkerEdgeColor','k','MarkerFaceColor',[.49 1 .63],'MarkerSize',7)
        end
        %% Ficheiros exportados
        gravartrajectorias=lower(gravartrajectorias);
        if gravartrajectorias=='s'
        pathname=fullfile(filepath,'\Resultados');

      </code></pre>
    </article>
    <p>Página 45</p>
    <article class="code45">
      <pre><code class="language-matlab">
        mkdir(pathname,nomeoutput)
        nomeoutputgeo=[nomeoutput 'geopath.txt'];
        nomeoutputmaq=[nomeoutput 'maqpath.txt'];
        geopathname=fullfile(pathname,'\',nomeoutput,nomeoutputgeo);
        maqpathname=fullfile(pathname,'\',nomeoutput,nomeoutputmaq);
        path=zeros(n1*size(xciclo,2),3);
        maq=zeros(n1*size(xciclo,2),4);
        for j=1:n1
        for k=1:size(xciclo,2)
        path(k+((j-1)*size(xciclo,2)),1)=xciclo(j,k);
        path(k+((j-1)*size(xciclo,2)),2)=yciclo(j,k);
        path(k+((j-1)*size(xciclo,2)),3)=zciclo(j,k);
        maq(k+((j-1)*size(xciclo,2)),1)=ficiclo(j,k);
        maq(k+((j-1)*size(xciclo,2)),2)=zciclo(j,k);
        maq(k+((j-1)*size(xciclo,2)),3)=rociclo(j,k);
        maq(k+((j-1)*size(xciclo,2)),4)=alfaciclo(1,k);
        end
        end
        % Trajectorias cartesianas (x y z)
        save(geopathname,'path','-ascii','-double','-tabs')
        % Trajectorias cilindricas/esfericas (fi z ro alfa)
        save(maqpathname,'maq','-ascii','-double','-tabs')
        %dlmwrite('maqpath.txt',maq,'delimiter','\t','precision','%.6f')
        end
        %% CNC
        if cnc=='s'
        Bcnc=zeros(1,size(zciclo,2));
        Bcnc2=zeros(1,size(zciclo,2));
        Ycnc=zeros(1,size(zciclo,2)); %Posição do fim da cabeça (onde passa a fibra). Ycnc é
        só usado para coord relativas por isso RefY é aplicado no mpf
        Xcnc=zeros(1,size(zciclo,2));
        Acnc=ficiclo(1,:);
        for k=1:size(zciclo,2)
        %Bcnc(1,k)=alfaciclo(1,k);
        ycnc=rociclo(1,k);
        i=0;
        rocnc=rociclo(1,k);
        while ycnc< rocnc+D
        i=i+0.01;
        ycnc=ycnc+i;

      </code></pre>
    </article>
    <p>Página 46</p>
    <article class="code46">
      <pre><code class="language-matlab">
        dxcnc=ycnc/tan(alfaciclo(1,k));
        if rim==rfm
        rocnc=rim;
        ycnc=rocnc+D;
        else
        rocnc=(((zciclo(1,k)+dxcnc)*dm/lm)+rim-(dm*zim/lm));
        end
        end
        Ycnc(1,k)=ycnc;
        Xcnc(1,k)=zciclo(1,k)+dxcnc;
        Bcnc2(1,k)=atan(rociclo(1,k)*tan(alfaciclo(1,k))/(Ycnc(1,k)*cos(asin(rociclo(1,k)
        /Ycnc(1,k)))));
        if Bcnc2(1,k)< 0
        Bcnc2(1,k)=Bcnc2(1,k)+pi;
        end
        Bcnc(1,k)=pi/2-Bcnc2(1,k);
        end
        Bcnc=Bcnc.*(180/pi);
        Acnc=Acnc.*(180/pi);
        %Coordenadas relativas
        difalfaciclo=zeros(1,size(zciclo,2)-1);
        difBcnc=zeros(1,size(zciclo,2)-1);
        difYcnc=zeros(1,size(zciclo,2)-1);
        difXcnc=zeros(1,size(zciclo,2)-1);
        difAcnc=zeros(1,size(zciclo,2)-1);
        for k=1:size(zciclo,2)-1
        difalfaciclo(1,k)=alfaciclo(1,k+1)-alfaciclo(1,k);
        difBcnc(1,k)=Bcnc(1,k+1)-Bcnc(1,k);
        difXcnc(1,k)=Xcnc(1,k+1)-Xcnc(1,k);
        difAcnc(1,k)=Acnc(1,k+1)-Acnc(1,k);
        difYcnc(1,k)=Ycnc(1,k+1)-Ycnc(1,k);
        end
        t1=1:size(difBcnc,2);
        t2=1:size(Bcnc,2);
        tempo=[];
        VXmaximo=[];
        VYmaximo=[];
        VAmaximo=[];
        VBmaximo=[];
        FeedMTP=[];
        AAreal=[];
        ABreal=[];
        AXreal=[];
        AYreal=[];
        aceleA=0;
        aceleB=0;
        aceleX=0;
        aceleY=0;
        VXmaximo(1,1)=0;
        VYmaximo(1,1)=0;
        VAmaximo(1,1)=0;

      </code></pre>
    </article>
    <p>Página 47</p>
    <article class="code47">
      <pre><code class="language-matlab">
        VBmaximo(1,1)=0;
        i=1;
        j=1;
        contador=0;
        breaker=0;
        csb1=0;
        while i<(size(difBcnc,2)+1)%for i=2:size(difBcnc,2)+1
        i=i+1;
        j=j+1;
        if breaker==0
        difAcnc1(1,j-1)=difAcnc(1,i-1);
        difBcnc1(1,j-1)=difBcnc(1,i-1);
        difXcnc1(1,j-1)=difXcnc(1,i-1);
        difYcnc1(1,j-1)=difYcnc(1,i-1);
        else
        end
        breaker=0;
        tempo(1,j-1)=difAcnc1(1,j-1)/(VAmax);
        tempo(2,j-1)=difBcnc1(1,j-1)/(VBmax);
        tempo(3,j-1)=difXcnc1(1,j-1)/(VXmax);
        tempo(4,j-1)=difYcnc1(1,j-1)/(VYmax);
        tempo(5,j-1)=vel*max(tempo(1:4,j-1));
        VXmaximo(1,j)=difXcnc1(1,j-1)/tempo(5,j-1);
        VYmaximo(1,j)=difYcnc1(1,j-1)/tempo(5,j-1);
        VAmaximo(1,j)=difAcnc1(1,j-1)/tempo(5,j-1);
        VBmaximo(1,j)=difBcnc1(1,j-1)/tempo(5,j-1);
        %Menor tempo de produção (velocidades máximas sempre)
        FeedMTP(1,j-1)=((difAcnc1(1,j-1)^2+difBcnc1(1,j-1)^2+difXcnc1(1,j-1)^2+difYcnc1(1,
        j-1)^2)^0.5)/(tempo(5,j-1)/60);
        %Acelerações
        AAreal(1,j)=abs(VAmaximo(1,j)-VAmaximo(1,j-1));
        AA1=VAmaximo(1,j)-VAmaximo(1,j-1);
        ABreal(1,j)=abs(VBmaximo(1,j)-VBmaximo(1,j-1));
        AB1=VBmaximo(1,j)-VBmaximo(1,j-1);
        AXreal(1,j)=abs(VXmaximo(1,j)-VXmaximo(1,j-1));
        AX1=VXmaximo(1,j)-VXmaximo(1,j-1);
        AYreal(1,j)=abs(VYmaximo(1,j)-VYmaximo(1,j-1));
        AY1=VYmaximo(1,j)-VYmaximo(1,j-1);
        %AA1=1;
        %AB1=1;
        %AX1=1;
        %AY1=1;
        csa=1;
        csb=1;
        if difAcnc1(1,j-1)==0 && difXcnc1(1,j-1)==0 && difYcnc1(1,j-1)==0 && difBcnc1(1,
        j-1)==0
        contador=contador+1;
        difAcnc1(1,j-1)=difAcnc1(1,j-1)+difAcnc(1,i);

      </code></pre>
    </article>
    <p>Página 48</p>
    <article class="code48">
      <pre><code class="language-matlab">
        difBcnc1(1,j-1)=difBcnc1(1,j-1)+difBcnc(1,i);
        difXcnc1(1,j-1)=difXcnc1(1,j-1)+difXcnc(1,i);
        difYcnc1(1,j-1)=difYcnc1(1,j-1)+difYcnc(1,i);
        breaker=1;
        j=j-1;
        end
        end
        %Parar maquina
        j=j+1;
        VXmaximo(1,j)=0;
        VYmaximo(1,j)=0;
        VAmaximo(1,j)=0;
        VBmaximo(1,j)=0;
        AAreal(1,j)=abs(VAmaximo(1,j)-VAmaximo(1,j-1));
        AA1=VAmaximo(1,j)-VAmaximo(1,j-1);
        ABreal(1,j)=abs(VBmaximo(1,j)-VBmaximo(1,j-1));
        AXreal(1,j)=abs(VXmaximo(1,j)-VXmaximo(1,j-1));
        AYreal(1,j)=abs(VYmaximo(1,j)-VYmaximo(1,j-1));
        %Desaceleração
        pAA=ceil(AAreal(1,j)/AAmax);
        %passos novos
        difAcncpasso=difAcnc1(1,j-2)/pAA;
        difBcncpasso=difBcnc1(1,j-2)/pAA;
        difXcncpasso=difXcnc1(1,j-2)/pAA;
        difYcncpasso=difYcnc1(1,j-2)/pAA;
        AApasso=AAreal(1,j)/pAA;
        poop2=j;
        for p=1:pAA
        difAcnc1(1,j-2)=difAcncpasso;
        difBcnc1(1,j-2)=difBcncpasso;
        difXcnc1(1,j-2)=difXcncpasso;
        difYcnc1(1,j-2)=difYcncpasso;
        if AA1< 0
        VAmaximo(1,j)=VAmaximo(1,j-1)-AApasso;
        tempope=difAcncpasso/VAmaximo(1,j);
        if p==pAA
        break
        end
        tempo(5,j-2)=tempope;
        VBmaximo(1,j)=difBcncpasso/tempope;
        VXmaximo(1,j)=difXcncpasso/tempope;
        VYmaximo(1,j)=difYcncpasso/tempope;
        else
        VAmaximo(1,j)=VAmaximo(1,j-1)+AApasso;
        tempope=difAcncpasso/VAmaximo(1,j);
        if p==pAA
        break
        end
        tempo(5,j-2)=tempope;
        VBmaximo(1,j)=difBcncpasso/tempope;

      </code></pre>
    </article>
    <p>Página 49</p>
    <article class="code49">
      <pre><code class="language-matlab">
        VXmaximo(1,j)=difXcncpasso/tempope;
        VYmaximo(1,j)=difYcncpasso/tempope;
        end
        AAreal(1,j)=abs(VAmaximo(1,j)-VAmaximo(1,j-1));
        ABreal(1,j)=abs(VBmaximo(1,j)-VBmaximo(1,j-1));
        AXreal(1,j)=abs(VXmaximo(1,j)-VXmaximo(1,j-1));
        AYreal(1,j)=abs(VYmaximo(1,j)-VYmaximo(1,j-1));
        FeedMTP(1,j-2)=(difAcnc1(1,j-2)^2+difBcnc1(1,j-2)^2+difXcnc1(1,j-2)
        ^2+difYcnc1(1,j-2)^2)^0.5/(tempo(5,j-2)/60);
        if p<pAA
        j=j+1;
        end
        end
        tempo(5,j-1)=0;
        %Verificação
        aceleA=0;
        aceleAa=[];
        a=0;
        aceleB=0;
        aceleBa=[];
        btt=0;
        aceleX=0;
        aceleXa=[];
        x=0;
        aceleY=0;
        aceleYa=[];
        y=0;
        velociA=0;
        velociB=0;
        velociX=0;
        velociY=0;
        ACNC=zeros(1,size(difAcnc1,2)+1);
        BCNC=zeros(1,size(difAcnc1,2)+1);
        XCNC=zeros(1,size(difAcnc1,2)+1);
        YCNC=zeros(1,size(difAcnc1,2)+1);
        ACNC(1,1)=Acnc(1,1);
        BCNC(1,1)=Bcnc(1,1);
        XCNC(1,1)=Xcnc(1,1);
        YCNC(1,1)=Ycnc(1,1);
        velocicheckA=zeros(1,size(difAcnc1,2)+1);
        velocicheckB=zeros(1,size(difAcnc1,2)+1);
        velocicheckX=zeros(1,size(difAcnc1,2)+1);
        velocicheckY=zeros(1,size(difAcnc1,2)+1);
        velocicheckA(1,1)=0;
        velocicheckB(1,1)=0;
        velocicheckX(1,1)=0;
        velocicheckY(1,1)=0;
        acelecheckA=zeros(1,size(difAcnc1,2));
        acelecheckB=zeros(1,size(difAcnc1,2));
        acelecheckX=zeros(1,size(difAcnc1,2));

      </code></pre>
    </article>
    <p>Página 50</p>
    <article class="code50">
      <pre><code class="language-matlab">
        acelecheckY=zeros(1,size(difAcnc1,2));
        tempoplot=zeros(1,size(difAcnc1,2)+1);
        tempoplot(1,1)=0;
        for j=2:size(difAcnc1,2)+1
        ACNC(1,j)=ACNC(1,j-1)+difAcnc1(1,j-1);
        BCNC(1,j)=BCNC(1,j-1)+difBcnc1(1,j-1);
        XCNC(1,j)=XCNC(1,j-1)+difXcnc1(1,j-1);
        YCNC(1,j)=YCNC(1,j-1)+difYcnc1(1,j-1);
        tempoplot(1,j)=tempoplot(1,j-1)+tempo(5,j-1);
        velocicheckA(1,j)=difAcnc1(1,j-1)/tempo(5,j-1);
        velocicheckB(1,j)=difBcnc1(1,j-1)/tempo(5,j-1);
        velocicheckX(1,j)=difXcnc1(1,j-1)/tempo(5,j-1);
        velocicheckY(1,j)=difYcnc1(1,j-1)/tempo(5,j-1);
        acelecheckA(1,j-1)=abs(velocicheckA(1,j)-velocicheckA(1,j-1));
        acelecheckB(1,j-1)=abs(velocicheckB(1,j)-velocicheckB(1,j-1));
        acelecheckX(1,j-1)=abs(velocicheckX(1,j)-velocicheckX(1,j-1));
        acelecheckY(1,j-1)=abs(velocicheckY(1,j)-velocicheckY(1,j-1));
        end
        j=j+1;
        velocicheckA(1,j)=0;
        velocicheckB(1,j)=0;
        velocicheckX(1,j)=0;
        velocicheckY(1,j)=0;
        acelecheckA(1,j-1)=abs(velocicheckA(1,j)-velocicheckA(1,j-1));
        acelecheckB(1,j-1)=abs(velocicheckB(1,j)-velocicheckB(1,j-1));
        acelecheckX(1,j-1)=abs(velocicheckX(1,j)-velocicheckX(1,j-1));
        acelecheckY(1,j-1)=abs(velocicheckY(1,j)-velocicheckY(1,j-1));
        t4=1:size(velocicheckA,2);
        t3=1:size(ACNC,2);
        for j=1:size(acelecheckA,2)
        if acelecheckA(1,j)>AAmax
        aceleA=aceleA+1;
        a=a+1;
        aceleAa(1,a)=j;
        end
        if acelecheckB(1,j)>ABmax
        aceleB=aceleB+1;
        btt=btt+1;
        aceleBa(1,btt)=j;
        end
        if acelecheckX(1,j)>AXmax
        aceleX=aceleX+1;
        x=x+1;
        aceleXa(1,x)=j;
        end
        if acelecheckY(1,j)>AYmax
        aceleY=aceleY+1;
        y=y+1;
        aceleYa(1,y)=j;
        end
        if VAmaximo(1,j)>VAmax

      </code></pre>
    </article>
    <p>Página 51</p>
    <article class="code51">
      <pre><code class="language-matlab">
        velociA=velociA+1;
        end
        if VBmaximo(1,j)>VBmax
        velociB=velociB+1;
        end
        if VXmaximo(1,j)>VXmax
        velociX=velociX+1;
        end
        if VYmaximo(1,j)>VYmax
        velociY=velociY+1;
        end
        end
        %Fazer os ficheiros
        gravarcnc=lower(gravarcnc);
        if gravarcnc=='s'
        nomeoutputspf=[nomeoutput 'CNCciclo.spf'];
        nomeoutputspf1=[nomeoutput 'CNCciclo'];
        nomeoutputmpf=[nomeoutput 'CNCmain.mpf'];
        cncspf=fullfile(pathname,'\',nomeoutput,nomeoutputspf);
        cncmpf=fullfile(pathname,'\',nomeoutput,nomeoutputmpf);
        Y0=RefY+rfm+D; %rfm pois é o maior raio do mandril
        Y1=RefY+rociclo(1,1)+D;
        F0=5000;
        X0=Xmin+zi-zim;
        % Ficheiro CNC .mpf
        fileID = fopen(cncmpf,'w');
        fprintf(fileID,'%4s %4s\r\n',';Pathwind','INEGI');
        fprintf(fileID,';%s\r\n',datestr(clock));
        fprintf(fileID,'M00\r\nN010 G01 G64 G90 G94 Y%.3f F%.3f\r\nN020 X%.3f B%.3f C0
        Z0\r\nN030 Y%.3f\r\nM00\r\nN040 %s P%d\r\nN050 M30\r\n',Y0,F0,X0,alfainicio,Y1,
        nomeoutputspf1,n1);
        fclose(fileID);
        %Feedmax=zeros(1,size(difAcnc,2));
        %Feedmax(1,1)=((difAcnc(1,1)^2+difBcnc(1,1)^2+difYcnc(1,1)^2+difYcnc(1,1)^2)^0.5)
        /tempo(5,1); %tempo/60
        % Ficheiro CNC .spf
        fileID = fopen(cncspf,'w');
        fprintf(fileID,'N010 G01 G91 G64 G94 A%.3f X%.3f Y%.3f B%.3f F%.3f\r\n',difAcnc(1,1),
        difXcnc(1,1),difYcnc(1,1),difBcnc(1,1),FeedMTP(1,1));
        for j=2:size(difAcnc1,2)-1
        %Feedmax(1,j)=((difAcnc(1,j)^2+difBcnc(1,j)^2+difYcnc(1,j)^2+difYcnc(1,j)^2)^0.5)/
        (tempo(5,j)); %tempo/60?
        if difAcnc1(1,j)==0 && difBcnc1(1,j)==0 && difXcnc1(1,j)==0 && difYcnc1(1,j)==0
        else
        fprintf(fileID,'N0%i0 A%.3f X%.3f Y%.3f B%.3f F%.3f\r\n',j,difAcnc1(1,j),
        difXcnc1(1,j),difYcnc1(1,j),difBcnc1(1,j),FeedMTP(1,j));
        end
        end

      </code></pre>
    </article>
    <p>Página 52</p>
    <article class="code52">
      <pre><code class="language-matlab">
        fprintf(fileID,'RET\r\n');
        fclose(fileID);
        end
        figure ('Name','Machine axes movement related to vector
        position','NumberTitle','off','Position',posfig);
        %B em funcao de t
        subplot(2,2,1)
        plot(t3,BCNC)
        title('Movement of axis B')
        xlabel('')
        ylabel('B / º')
        set(gcf,'color','w');
        grid on;
        %A em funcao de t
        subplot(2,2,2)
        plot(t3,ACNC)
        title('Movement of axis A')
        xlabel('')
        ylabel('A / º')
        set(gcf,'color','w');
        grid on;
        %X em funcao de t
        subplot(2,2,3)
        plot(t3,XCNC)
        title('Movement of axis X')
        xlabel('')
        ylabel('X / mm')
        set(gcf,'color','w');
        grid on;
        %Y em funcao de t
        subplot(2,2,4)
        plot(t3,YCNC);
        title('Movement of axis Y')
        xlabel('')
        ylabel('Y / mm')
        set(gcf,'color','w');
        grid on;
        figure ('Name','Machine axis movement related to time','NumberTitle','off','Position',
        posfig);
        %B em funcao de t
        subplot(2,2,1)
        plot(tempoplot,BCNC)
        title('Movement of axis B')
        xlabel('t / s')
        ylabel('B / º')
        set(gcf,'color','w');

      </code></pre>
    </article>
    <p>Página 53</p>
    <article class="code53">
      <pre><code class="language-matlab">
        grid on;
        %A em funcao de t
        subplot(2,2,2)
        plot(tempoplot,ACNC)
        title('Movement of axis A')
        xlabel('t / s')
        ylabel('A / º')
        set(gcf,'color','w');
        grid on;
        %X em funcao de t
        subplot(2,2,3)
        plot(tempoplot,XCNC)
        title('Movement of axis X')
        xlabel('t / s')
        ylabel('X / mm')
        set(gcf,'color','w');
        grid on;
        %Y em funcao de t
        subplot(2,2,4)
        plot(tempoplot,YCNC);
        title('Movement of axis Y')
        xlabel('t / s')
        ylabel('Y / mm')
        set(gcf,'color','w');
        grid on;
        figure ('Name','Velocidade dos eixos da máquina em função do
        tempo','NumberTitle','off','Position',posfig);
        tempoplot1=zeros(1,size(tempoplot,2)+1);
        tempoplot1(1,1:size(tempoplot,2))=tempoplot(1,:);
        tempoplot1(1,size(tempoplot1,2))=tempoplot1(1,size(tempoplot1,2)-1)+0.0001;
        %B em funcao de t
        subplot(2,2,1)
        plot(tempoplot1,velocicheckB)
        title('Velocity of axis B')
        xlabel('t / s')
        ylabel('VB / º/s')
        set(gcf,'color','w');
        grid on;
        %A em funcao de t
        subplot(2,2,2)
        plot(tempoplot1,velocicheckA)
        title('Velocity of axis A')
        xlabel('t / s')
        ylabel('VA / º/s')
        set(gcf,'color','w');
        grid on;
        %X em funcao de t
        subplot(2,2,3)

      </code></pre>
    </article>
    <p>Página 54</p>
    <article class="code54">
      <pre><code class="language-matlab">
        plot(tempoplot1,velocicheckX)
        title('Velocity of axis X')
        xlabel('t / s')
        ylabel('VX / mm/s')
        set(gcf,'color','w');
        grid on;
        %Y em funcao de t
        subplot(2,2,4)
        plot(tempoplot1,velocicheckY);
        title('Velocity of axis Y')
        xlabel('t / s')
        ylabel('VY / mm/s')
        set(gcf,'color','w');
        grid on;
        end
        %% Sobreposições
        switch lower(sobre)
        case {'sobreposiçao3','sobreposição3'}
        disp('Sobreposição')
        %criar matriz para ordenar por z
        zsobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        alfasobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        fisobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        rosobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        xsobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        ysobre=zeros(size(zciclo,2)*size(zciclo,1),1);
        numeracaomatriz=zeros(size(zciclo,2)*size(zciclo,1),1);
        contsobre=0;
        for j=1:size(zciclo,1)
        for i=1:size(zciclo,2)
        contsobre=contsobre+1;
        zsobre(contsobre,1)=zciclo(j,i);
        alfasobre(contsobre,1)=alfaciclo(1,i);
        fisobre(contsobre,1)=ficiclo(j,i);
        rosobre(contsobre,1)=rociclo(j,i);
        xsobre(contsobre,1)=xciclo(j,i);
        ysobre(contsobre,1)=yciclo(j,i);
        numeracaomatriz(contsobre,1)=contsobre;
        end
        end
        %Novo vector fi - errado!!!!!
        finovo1=zeros(size(fisobre));
        for i=1:size(fisobre,1)
        finovo1(i,1)=fisobre(i,1);
        while finovo1(i,1)>2*pi
        finovo1(i,1)=finovo1(i,1)-2*pi;

      </code></pre>
    </article>
    <p>Página 55</p>
    <article class="code55">
      <pre><code class="language-matlab">
        end
        end
        %matriz com todos os ciclos
        matrizsobre=[zsobre numeracaomatriz finovo1 rosobre alfasobre xsobre ysobre];
        %matriz ordenada
        matrizsobreordenada=sortrows(matrizsobre);
        case{'coco'}
        %restantes paths para a matriz ordenada
        dfilargurasobre(:,1)=(b./(2.*rosobre(:,1))).*(cos(alfasobre(:,1)));
        dzlargurasobre(:,1)=(b/2).*sin(alfasobre(:,1)).*cos(tau);
        fisobrela=zeros(2*NP+1,size(fisobre,1));
        zsobrela=zeros(4*NP+2,size(fisobre,1));
        rosobrela=zeros(2*NP+1,size(fisobre,1));
        for i=1:(2*NP+1)
        fisobrela(i,:)=finovo1(1,:)-dfilargura(1,:)+(i-1)*(dfilargura(1,:)/NP);
        zsobrela(i,:)=zciclo(1,:)+dzlargura(1,:)-(i-1)*(dzlargura(1,:)/NP);
        rosobrela(i,:)=((zciclola(i,:)*dm/lm)+rim-(dm*zim/lm));
        end
        firealla=zeros(size(ficiclo,1),(2*NP+1));
        for l=1:(2*NP+1)
        firealla(:,l)=fireal-dfilargura(1,k)+(l-1)*(dfilargura(1,k)/NP);
        end
        %T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin(alfaciclo(1,i)) cos(alfaciclo
        (1,i))];
        for k=1:size(zsobre,1)
        i=k-1;
        if i>0 && i<=size(zsobre,1)
        while abs(matrizsobreordenada(i,1)-matrizsobreordenada(k,1))/cos(tau)<b
        dfi=abs(matrizsobreordenada(i,2)-matrizsobreordenada(k,2));
        if dfi>pi
        dfi=2*pi-dfi;
        end
        if dfi<(b/matrizsobreordenada(k,3))
        end
        i=i-1;
        if i<=0
        break
        end
        if i>size(zsobre,1)
        break
        end
        end
        end

      </code></pre>
    </article>
    <p>Página 56</p>
    <article class="code56">
      <pre><code class="language-matlab">
        j=k+1;
        if j>0 && j<=size(zsobre,1)
        while abs(matrizsobreordenada(j,1)-matrizsobreordenada(k,1))/cos(tau)< b
        dfi=abs(matrizsobreordenada(j,2)-matrizsobreordenada(k,2));
        if dfi>pi
        dfi=2*pi-dfi;
        end
        j=j+1;
        if j<=0
        break
        end
        if j>size(zsobre,1)
        break
        end
        end
        end
        end
        case {'sobreposiçao1','sobreposiçao2','sobreposição1','sobreposição2'}
        if lower(sobre)=='sobreposiçao1'
        disp('Sobreposição do primeiro ciclo')
        else
        disp('Sobreposição')
        end
        %Novo vector fi
        finovo1=zeros(n1,size(ficiclo,2));
        for i=1:size(ficiclo,2)
        finovo1(1,i)=ficiclo(1,i);
        while finovo1(1,i)>2*pi
        finovo1(1,i)=finovo1(1,i)-2*pi;
        end
        end
        % Sobreposição
        for k=1:size(zciclo,2)
        i=1;
        while ficiclo(1,i)<(ficiclo(1,k)-2*pi)
        if abs(zciclo(1,i)-zciclo(1,k))/cos(tau)< b
        if abs(finovo1(1,i)-finovo1(1,k))<(b/rociclo(1,i))
        finovo=ficiclo(1,k);
        fireal=ficiclo(1,k);
        dfireal=abs(ficiclo(1,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;

      </code></pre>
    </article>
    <p>Página 57</p>
    <article class="code57">
      <pre><code class="language-matlab">
        dfi1=abs(ficiclo(1,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end
        firealla=zeros((2*NP+1),1);
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*(dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin(alfaciclo(1,i)) cos(alfaciclo
        (1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)
        for m=1:(2*NP+1)
        if rociclola(l,k)>rociclola(m,i)
        distla(m,l)=(((zciclola(l,k)-zciclola(m,i))/cos(tau))^2+((firealla
        (l,1)-ficiclola(m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,i))/cos(tau) (firealla
        (l,1)-ficiclola(m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))/cos(tau); (firealla(l,1)-
        ficiclola(m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclola(m,i))/cos(tau))^2+((firealla
        (l,1)-ficiclola(m,i))*rociclola(m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,i))/cos(tau) (firealla
        (l,1)-ficiclola(m,i))*rociclola(m,i)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))/cos(tau); (firealla(l,1)-
        ficiclola(m,i))*rociclola(m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))< b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1

      </code></pre>
    </article>
    <p>Página 58</p>
    <article class="code58">
      <pre><code class="language-matlab">
        if abs(distlava(posi-1,l))<=abs(distlava(posi+1,l))
        rociclola(l,k)=((abs(distlava(posi-1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava(posi-1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        end
        end
        end
        else
        if abs(finovo1(1,i)-finovo1(1,k))>(2*pi-(b/rociclo(1,i)))
        finovo=ficiclo(1,k);
        fireal=ficiclo(1,k);
        dfireal=abs(ficiclo(1,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;
        dfi1=abs(ficiclo(1,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end
        firealla=zeros((2*NP+1),1);
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*(dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin(alfaciclo(1,i)) cos(alfaciclo
        (1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)

      </code></pre>
    </article>
    <p>Página 59</p>
    <article class="code59">
      <pre><code class="language-matlab">
        for m=1:(2*NP+1)
        if rociclola(l,k)>rociclola(m,i)
        distla(m,l)=(((zciclola(l,k)-zciclola(m,i))/cos(tau))^2+((firealla
        (l,1)-ficiclola(m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,i))/cos(tau) (firealla
        (l,1)-ficiclola(m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))/cos(tau); (firealla(l,1)-
        ficiclola(m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclola(m,i))/cos(tau))^2+((firealla
        (l,1)-ficiclola(m,i))*rociclola(m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,i))/cos(tau) (firealla
        (l,1)-ficiclola(m,i))*rociclola(m,i)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))/cos(tau); (firealla(l,1)-
        ficiclola(m,i))*rociclola(m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))< b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1
        if abs(distlava(posi-1,l))<=abs(distlava(posi+1,l))
        rociclola(l,k)=((abs(distlava(posi-1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava(posi-1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);

      </code></pre>
    </article>
    <p>Página 60</p>
    <article class="code60">
      <pre><code class="language-matlab">
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))*rociclola(posi,i)+abs
        (distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))+abs(distlava(posi,
        l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        end
        end
        end
        end
        end
        end
        i=i+1;
        end
        end
        % Cartesianas multiplas linhas
        xciclola=zeros(4*NP+2,size(ficiclola,2));
        yciclola=zeros(4*NP+2,size(ficiclola,2));
        for n=1:2*NP+1
        xciclola(n,:)=rociclola(n,:).*cos(ficiclola(n,:));
        yciclola(n,:)=rociclola(n,:).*sin(ficiclola(n,:));
        end
        c=1;
        for n=2*NP+2:2*(2*NP+1)
        xciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*cos(ficiclola((2*NP+2-
        c),:));
        yciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*sin(ficiclola((2*NP+2-
        c),:));
        zciclola(n,:)=zciclola((2*NP+2-c),:)-esp*sin(tau);
        c=c+1;
        end
        rociclolae=[];
        ficiclolae=[];
        zciclolae=[];
        rociclolae(1,:,:)=rociclola(:,:);
        ficiclolae(1,:,:)=ficiclola(:,:);
        zciclolae(1,:,:)=zciclola(:,:);
        %Plot Mandril e trajectoria com multiplas linhas
        figure ('Name','Primeira camada','NumberTitle','off','Position',posfig);
        surf(Z,X,Y,'FaceColor','c','FaceAlpha',.
        7,'EdgeColor','none','LineStyle','none')
        hold on;
        surf(zciclola(:,:),yciclola(:,:),xciclola
        (:,:),'FaceColor','r','EdgeColor','none','LineStyle','none')
        %hold on;
        %plot3(zciclo(1,:),xciclo(1,:),yciclo(1,:),'r','Linewidth',2);
        plot3(zciclola(1,:),yciclola(1,:),xciclola(1,:),'k','Linewidth',0.5);
        plot3(zciclola((2*NP+1),:),yciclola((2*NP+1),:),xciclola
        ((2*NP+1),:),'k','Linewidth',0.5);

      </code></pre>
    </article>
    <p>Página 61</p>
    <article class="code61">
      <pre><code class="language-matlab">
        plot3(zciclola((2*NP+2),:),yciclola((2*NP+2),:),xciclola
        ((2*NP+2),:),'k','Linewidth',0.5);
        plot3(zciclola(2*(2*NP+1),:),yciclola(2*(2*NP+1),:),xciclola(2*
        (2*NP+1),:),'k','Linewidth',0.5);
        plot3(zciclola((3*NP+2),:),yciclola((3*NP+2),:),xciclola
        ((3*NP+2),:),'b','Linewidth',0.5);
        axis equal
        title('Primeira camada')
        xlabel('z')
        ylabel('y')
        zlabel('x')
        set(gcf,'color','w');
        grid on;
        switch lower(sobre)
        case {'sobreposiçao2','sobreposição2'}
        disp('Sobreposição de todos os ciclos primeira camada')
        % Todos os ciclos
        for o=2:n1
        % pegar nas trajectórias já geradas e adicionar a largura/espessura
        % (isto pode ser lá em cima, só não é representado)
        %verificar se tem paths por baixo
        % Restantes Paths - NP
        ficiclola=zeros(2*NP+1,size(ficiclo,2));
        zciclola=zeros(4*NP+2,size(ficiclola,2));
        rociclola=zeros(2*NP+1,size(ficiclo,2));
        for i=1:(2*NP+1)
        ficiclola(i,:)=ficiclo(o,:)-dfilargura(1,:)+(i-1)*(dfilargura(1,:)
        /NP);
        zciclola(i,:)=zciclo(o,:)+dzlargura(1,:)-(i-1)*(dzlargura(1,:)/NP);
        rociclola(i,:)=((zciclola(i,:)*dm/lm)+rim-(dm*zim/lm));
        end
        %Sobreposição ciclos anteriores
        %Novo vector fi
        for i=1:size(ficiclo,2)
        finovo1(o,i)=ficiclo(o,i);
        while finovo1(o,i)>2*pi
        finovo1(o,i)=finovo1(o,i)-2*pi;
        end
        end
        for g=1:o-1
        for k=1:size(zciclo,2) %ciclo 'o'
        %i=1;
        for i=1:size(zciclo,2) %while ficiclo(1,i)<(ficiclo(1,k)-2*pi) %
        ciclo 'g'
        if abs(zciclo(g,i)-zciclo(o,k))/cos(tau)<b
        if abs(finovo1(g,i)-finovo1(o,k))<(b/rociclolae(g,NP+1,i))

      </code></pre>
    </article>
    <p>Página 62</p>
    <article class="code62">
      <pre><code class="language-matlab">
        finovo=ficiclo(o,k);
        fireal=ficiclo(o,k);
        dfireal=abs(ficiclo(g,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;
        dfi1=abs(ficiclo(g,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end
        firealla=zeros((2*NP+1),1);
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*
        (dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin
        (alfaciclo(1,i)) cos(alfaciclo(1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)
        for m=1:(2*NP+1)
        if rociclola(l,k)>rociclolae(g,m,i)
        distla(m,l)=(((zciclola(l,k)-zciclolae(g,
        m,i))/cos(tau))^2+((firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclolae
        (g,m,i))/cos(tau) (firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclolae(g,m,i))
        /cos(tau); (firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclolae(g,
        m,i))/cos(tau))^2+((firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclolae
        (g,m,i))/cos(tau) (firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i)];
        distlav1=[(zciclola(l,k)-zciclolae(g,m,i))
        /cos(tau); (firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))< b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));

      </code></pre>
    </article>
    <p>Página 63</p>
    <article class="code63">
      <pre><code class="language-matlab">
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1
        if abs(distlava(posi-1,l))<=abs(distlava
        (posi+1,l))
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi-1,i))/(abs(distlava
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi-1,i))/(abs(distlava
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        end
        end
        end
        else
        if abs(finovo1(g,i)-finovo1(o,k))>(2*pi-(b/rociclolae
        (g,1,i)))
        finovo=ficiclo(o,k);
        fireal=ficiclo(o,k);
        dfireal=abs(ficiclo(g,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;
        dfi1=abs(ficiclo(g,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end
        firealla=zeros((2*NP+1),1);

      </code></pre>
    </article>
    <p>Página 64</p>
    <article class="code64">
      <pre><code class="language-matlab">
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*
        (dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin
        (alfaciclo(1,i)) cos(alfaciclo(1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)
        for m=1:(2*NP+1)
        if rociclola(l,k)>rociclolae(g,m,i)
        distla(m,l)=(((zciclola(l,k)-zciclolae(g,
        m,i))/cos(tau))^2+((firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclolae
        (g,m,i))/cos(tau) (firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclolae(g,m,i))
        /cos(tau); (firealla(l,1)-ficiclolae(g,m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclolae(g,
        m,i))/cos(tau))^2+((firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclolae
        (g,m,i))/cos(tau) (firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i)];
        distlav1=[(zciclola(l,k)-zciclolae(g,m,i))
        /cos(tau); (firealla(l,1)-ficiclolae(g,m,i))*rociclolae(g,m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))< b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1
        if abs(distlava(posi-1,l))<=abs(distlava
        (posi+1,l))
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi-1,i))/(abs(distlava
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);

      </code></pre>
    </article>
    <p>Página 65</p>
    <article class="code65">
      <pre><code class="language-matlab">
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi-1,i))/(abs(distlava
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclolae(g,posi,i)+abs(distlava(posi,l))*rociclolae(g,posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        end
        end
        end
        end
        end
        %i=i+1;
        end
        end
        end
        end
        %Sobreposição próprio ciclo - copiar de cima
        for k=1:size(zciclo,2)
        i=1;
        while ficiclo(o,i)<(ficiclo(o,k)-2*pi)
        if abs(zciclo(o,i)-zciclo(o,k))/cos(tau)< b
        if abs(finovo1(o,i)-finovo1(o,k))<(b/rociclo(o,i))
        finovo=ficiclo(o,k);
        fireal=ficiclo(o,k);
        dfireal=abs(ficiclo(o,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;
        dfi1=abs(ficiclo(o,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end

      </code></pre>
    </article>
    <p>Página 66</p>
    <article class="code66">
      <pre><code class="language-matlab">
        firealla=zeros((2*NP+1),1);
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*
        (dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin
        (alfaciclo(1,i)) cos(alfaciclo(1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)
        for m=1:(2*NP+1)
        if rociclola(l,k)>rociclola(m,i)
        distla(m,l)=(((zciclola(l,k)-zciclola(m,
        i))/cos(tau))^2+((firealla(l,1)-ficiclola(m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,
        i))/cos(tau) (firealla(l,1)-ficiclola(m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))
        /cos(tau); (firealla(l,1)-ficiclola(m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclola(m,
        i))/cos(tau))^2+((firealla(l,1)-ficiclola(m,i))*rociclola(m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-zciclola(m,
        i))/cos(tau) (firealla(l,1)-ficiclola(m,i))*rociclola(m,i)];
        distlav1=[(zciclola(l,k)-zciclola(m,i))
        /cos(tau); (firealla(l,1)-ficiclola(m,i))*rociclola(m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))< b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1
        if abs(distlava(posi-1,l))<=abs(distlava
        (posi+1,l))
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))
        +abs(distlava(posi,l))))+(esp/cos(tau));

      </code></pre>
    </article>
    <p>Página 67</p>
    <article class="code67">
      <pre><code class="language-matlab">
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))
        +abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava(posi-1,l))
        *rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava(posi-1,l))
        +abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava(posi+1,l))
        *rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava(posi+1,l))
        +abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-esp*sin(tau);
        end
        end
        end
        end
        else
        if abs(finovo1(o,i)-finovo1(o,k))>(2*pi-(b/rociclo(o,
        i)))
        finovo=ficiclo(o,k);
        fireal=ficiclo(o,k);
        dfireal=abs(ficiclo(o,i)-finovo);
        while finovo>0
        finovo=finovo-2*pi;
        dfi1=abs(ficiclo(o,i)-finovo);
        if dfi1< dfireal
        fireal=finovo;
        dfireal=dfi1;
        end
        end
        firealla=zeros((2*NP+1),1);
        for l=1:(2*NP+1)
        firealla(l,1)=fireal-dfilargura(1,k)+(l-1)*
        (dfilargura(1,k)/NP);
        end
        T=[cos(alfaciclo(1,i)) sin(alfaciclo(1,i));-sin
        (alfaciclo(1,i)) cos(alfaciclo(1,i))];
        % Multiplas linhas
        for l=1:(2*NP+1)
        for m=1:(2*NP+1)

      </code></pre>
    </article>
    <p>Página 68</p>
    <article class="code68">
      <pre><code class="language-matlab">
        if rociclola(l,k)>rociclola(m,i)
        distla(m,l)=(((zciclola(l,k)-zciclola
        (m,i))/cos(tau))^2+((firealla(l,1)-ficiclola(m,i))*rociclola(l,k))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-
        zciclola(m,i))/cos(tau) (firealla(l,1)-ficiclola(m,i))*rociclola(l,k)];
        distlav1=[(zciclola(l,k)-zciclola(m,
        i))/cos(tau); (firealla(l,1)-ficiclola(m,i))*rociclola(l,k)];
        else
        distla(m,l)=(((zciclola(l,k)-zciclola
        (m,i))/cos(tau))^2+((firealla(l,1)-ficiclola(m,i))*rociclola(m,i))^2)^0.5;
        distlav(m,l,:)=[(zciclola(l,k)-
        zciclola(m,i))/cos(tau) (firealla(l,1)-ficiclola(m,i))*rociclola(m,i)];
        distlav1=[(zciclola(l,k)-zciclola(m,
        i))/cos(tau); (firealla(l,1)-ficiclola(m,i))*rociclola(m,i)];
        end
        distlava1=T*distlav1;
        distlava(m,l)=distlava1(2,1);
        end
        end
        for l=1:(2*NP+1)
        if abs(distla(1,l))< b && abs(distla(2*NP+1,l))
        < b
        minimo=abs(distlava(1,l));
        posi=1;
        for m=1:(2*NP+1)
        minimo1=abs(distlava(m,l));
        if minimo1< minimo
        minimo=minimo1;
        posi=m;
        end
        end
        if posi~=2*NP+1 && posi~=1
        if abs(distlava(posi-1,l))<=abs
        (distlava(posi+1,l))
        rociclola(l,k)=((abs(distlava
        (posi-1,l))*rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-
        esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava
        (posi+1,l))*rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-
        esp*sin(tau);
        end
        else
        if posi==2*NP+1
        rociclola(l,k)=((abs(distlava
        (posi-1,l))*rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi-1,i))/(abs(distlava

      </code></pre>
    </article>
    <p>Página 69</p>
    <article class="code69">
      <pre><code class="language-matlab">
        (posi-1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-
        esp*sin(tau);
        else
        rociclola(l,k)=((abs(distlava
        (posi+1,l))*rociclola(posi,i)+abs(distlava(posi,l))*rociclola(posi+1,i))/(abs(distlava
        (posi+1,l))+abs(distlava(posi,l))))+(esp/cos(tau));
        zciclola(l,k)=zciclola(l,k)-
        esp*sin(tau);
        end
        end
        end
        end
        end
        end
        end
        i=i+1;
        end
        end
        % Cartesianas multiplas linhas
        xciclola=zeros(4*NP+2,size(ficiclola,2));
        yciclola=zeros(4*NP+2,size(ficiclola,2));
        for n=1:2*NP+1
        xciclola(n,:)=rociclola(n,:).*cos(ficiclola(n,:));
        yciclola(n,:)=rociclola(n,:).*sin(ficiclola(n,:));
        end
        c=1;
        for n=2*NP+2:2*(2*NP+1)
        xciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*cos(ficiclola
        ((2*NP+2-c),:));
        yciclola(n,:)=(rociclola((2*NP+2-c),:)+esp/cos(tau)).*sin(ficiclola
        ((2*NP+2-c),:));
        zciclola(n,:)=zciclola((2*NP+2-c),:)-esp*sin(tau);
        c=c+1;
        end
        %Arrays com todas as coordenadas
        rociclolae(o,:,:)=rociclola(:,:);
        ficiclolae(o,:,:)=ficiclola(:,:);
        zciclolae(o,:,:)=zciclola(:,:);
        xciclolae(o,:,:)=xciclola(:,:);
        yciclolae(o,:,:)=yciclola(:,:);
        %Plot de tudo
        surf(zciclola(:,:),yciclola(:,:),xciclola
        (:,:),'FaceColor','r','EdgeColor','none','LineStyle','none')
        plot3(zciclola(1,:),yciclola(1,:),xciclola(1,:),'k','Linewidth',0.5);
        plot3(zciclola((2*NP+1),:),yciclola((2*NP+1),:),xciclola
        ((2*NP+1),:),'k','Linewidth',0.5);
        plot3(zciclola((2*NP+2),:),yciclola((2*NP+2),:),xciclola

      </code></pre>
    </article>
    <p>Página 70</p>
    <article class="code70">
      <pre><code class="language-matlab">
        ((2*NP+2),:),'k','Linewidth',0.5);
        plot3(zciclola(2*(2*NP+1),:),yciclola(2*(2*NP+1),:),xciclola(2*
        (2*NP+1),:),'k','Linewidth',0.5);
        plot3(zciclola((3*NP+2),:),yciclola((3*NP+2),:),xciclola
        ((3*NP+2),:),'b','Linewidth',0.5);
        end
        end
        end
        disp('Fim');
      </code></pre>
    </article>
  </section>
  <section id="apendix_b">
    <h1>Appendix A</h1>
    <h1>Matlab Code</h1>
    <h2>A.2  Christoffel coefficients function</h2>
    <article class="code_ChristoffelCoefficientsFunction">
      <pre><code class="language-matlab">
        function [chr,gg1,gg2,e,g,ev,eu,gv,gu]=Christoffel_funcao_1(S,u,v,ro)
        S
        %Primeira formula fundamental
        e=formula(diff(S,u));
        E1=dot(e,e);
        E=simplify(E1);
        g=formula(diff(S,v));
        G1=dot(g,g);
        G=simplify(G1);
        F1=dot(g,e);
        F=simplify(F1);
        gg1(1,1)=E;
        gg1(1,2)=F;
        gg1(2,1)=F;
        gg1(2,2)=G;
        n=cross(e,g)/norm(cross(e,g));
        L=dot(n,diff(e,u));
        M=dot(n,diff(e,v));
        N=dot(n,diff(g,v));
        gg2(1,1)=L;
        gg2(1,2)=M;
        gg2(2,1)=M;
        gg2(2,2)=N;
        %Símbolos Christoffel
        chr(1,1,1)=simplify((G*(diff(E,u))-2*F*diff(F,u)+F*diff(E,v))/(2*(E*G-F^2)));
        chr(1,1,2)=simplify((2*E*(diff(F,u))-E*diff(E,v)-F*diff(E,u))/(2*(E*G-F^2)));
        chr(1,2,1)=simplify((G*(diff(E,v))-F*diff(G,u))/(2*(E*G-F^2)));
        chr(2,1,1)=chr(1,2,1);
        chr(1,2,2)=simplify((E*(diff(G,u))-F*diff(E,v))/(2*(E*G-F^2)));
        chr(2,1,2)=chr(1,2,2);
        chr(2,2,1)=simplify((2*G*(diff(F,v))-G*diff(G,u)-F*diff(G,v))/(2*(E*G-F^2)));
        chr(2,2,2)=simplify((E*(diff(G,v))-2*F*diff(F,v)-F*diff(G,u))/(2*(E*G-F^2)));
        ev=simplify(diff(gg1(1,1),v));
        eu=simplify(diff(gg1(1,1),u));
        gv=simplify(diff(gg1(2,2),v));
        gu=simplify(diff(gg1(2,2),u));
        end
      </code></pre>
    </article>

  </section>
  <section id="apendix_c">
    <h1>Appendix A</h1>
    <h1>Matlab Code</h1>
    <h2>A.3 Pattern determination</h2>
      <article class="code_PatternDetermination_1">
        <pre><code class="language-matlab">
        %Determinação do padrão
        clear all;
        clc;
        %Dados padrão
        N=89;
        d=13;
        %Dados requisitos
        r=20;
        bmin=2;
        bmax=6;
        alfamin=40*pi/180;
        alfamax=50*pi/180;
        fifinalmax=55; %para alfamax
        fifinalmin=45;%para alfamin
        %% Dando valores de N e d
        A(1,1)=N;
        A(1,2)=d;
        C(1,1)=1;
        C(1,2)=0;
        D(1,1)=0;
        D(1,2)=1;
        E(1,2)=1;
        i=3;
        A(1,i)=mod(A(1,i-2),A(1,i-1));
        B(1,i)=floor(A(1,i-2)/A(1,i-1));
        C(1,i)=B(1,i)*C(1,i-1)+C(1,i-2);
        D(1,i)=B(1,i)*D(1,i-1)+D(1,i-2);
        E(1,i)=E(1,i-1)*(-1);
        while mod(A(1,i-2),A(1,i-1))~=0
        i=i+1;
        A(1,i)=mod(A(1,i-2),A(1,i-1));
        B(1,i)=floor(A(1,i-2)/A(1,i-1));
        C(1,i)=B(1,i)*C(1,i-1)+C(1,i-2);
        D(1,i)=B(1,i)*D(1,i-1)+D(1,i-2);
        E(1,i)=E(1,i-1)*(-1);
        end
        m=C(1,i-1);
        n=D(1,i-1);
        s=E(1,i-1);
        %% Dando intervalos de b e alfa
        Nmin=2*pi*r*cos(alfamax)/bmax;
        Nmax=2*pi*r*cos(alfamin)/bmin;
        Nmin1=ceil(Nmin);
        Nmax1=floor(Nmax);
        </code></pre>
      </article>
      <article class="code_PatternDetermination_2">
        <pre><code class="language-matlab">
        int=Nmax1-Nmin1;
        l=Nmin1;
        pad=0;
        for i=1:int+1
        Dmin=fifinalmin*l;
        Dmax=fifinalmax*l;
        Dmin1=ceil(Dmin);
        Dmax1=floor(Dmax);
        p=0;
        l1(i,1)=l;
        for j=Dmin1:Dmax1
        p=p+1;
        d1(i,p)=mod(j,l);
        if d1(i,p)~=0
        A(1,1)=l;
        A(1,2)=d1(i,p);
        C(1,1)=1;
        C(1,2)=0;
        D(1,1)=0;
        D(1,2)=1;
        E(1,2)=1;
        k=3;
        A(1,k)=mod(A(1,k-2),A(1,k-1));
        B(1,k)=floor(A(1,k-2)/A(1,k-1));
        C(1,k)=B(1,k)*C(1,k-1)+C(1,k-2);
        D(1,k)=B(1,k)*D(1,k-1)+D(1,k-2);
        E(1,k)=E(1,k-1)*(-1);
        while mod(A(1,k-2),A(1,k-1))~=0
        k=k+1;
        A(1,k)=mod(A(1,k-2),A(1,k-1));
        B(1,k)=floor(A(1,k-2)/A(1,k-1));
        C(1,k)=B(1,k)*C(1,k-1)+C(1,k-2);
        D(1,k)=B(1,k)*D(1,k-1)+D(1,k-2);
        E(1,k)=E(1,k-1)*(-1);
        end
        m1=C(1,k-1);
        n1=D(1,k-1);
        s=E(1,k-1);
        if d1(i,p)*n1-l*m1==1
        pad=pad+1;
        padrao(pad,1)=l; %N
        padrao(pad,2)=d1(i,p); %d
        padrao(pad,3)=m1; %m
        padrao(pad,4)=n1; %n
        padrao(pad,5)=s; %sinal
        </code></pre>
      </article>
      <article class="code_PatternDetermination_3">
        <pre><code class="language-matlab">
        padrao(pad,6)=d1(i,p)*n1-l*m1; %resultado da dio
        padrao(pad,7)=j; %D
        padrao(pad,8)=j/l; %w=D/N
        else
        if d1(i,p)*n1-l*m1==-1
        pad=pad+1;
        padrao(pad,1)=l;
        padrao(pad,2)=d1(i,p);
        padrao(pad,3)=m1;
        padrao(pad,4)=n1;
        padrao(pad,5)=s;
        padrao(pad,6)=d1(i,p)*n1-l*m1;
        padrao(pad,7)=j;
        padrao(pad,8)=j/l;
        end
        end
        end
        end
        l=l+1;
        end
        </code></pre>
      </article>
  </section>
  <section>
    <h1>Appendix B</h1>
    <h1>User's Manual</h1>
    Pathwind is a software that aims to simulate filament winding along axis-symmetric
    mandrels. It is able to generate paths and patterns for different mandrel geometries
    and tow properties as well as generate CNC code for different filament winding machines. The software was first developed as part of a Master thesis while working in
    INEGI.
    <h2>B.1 Structure</h2>
    The software follows this general structure:
    1. Data input
    (a) Mandrel geometry
    (b) Tow properties
    (c) Friction coefficient
    (d) Machine parameters (only necessary if CNC output is required)
    (e) Desired discretization (distance between points in the path)
    (f) Type of overlap requested
    2. Path creation for first cycle
    (a) Geodesic path for useful area
    (b) First turnaround
    (c) Geodesic path
    (d) Second turnaround
    3. First cycle vector assembly
    4. Representing the tow geometry along the first cycle
    5. Representing the variation of different parameters along one cycle
    6. Determining the path for all cycles
    7. Geometric output of paths
    8. CNC code
    (a) Generating CNC code
    (b) Verifying that position, velocity and acceleration are within boundary
    conditions
    (c) CNC code output
    (d) Machine axis movement
    9. Tow overlap and real trajectories
    <h2>B.2 Data input</h2>
    rim - Mandrel radius on the left end in mm
    rfm - Mandrel radius on the right end in mm
    zim - Coordinate of the left end of the mandrel in mm
    zfm - Coordinate of the right end of the mandrel in mm
    zig - Coordinate of the left geodesic end of the mandrel in mm
    zi - Coordinate of the beginning of the winding in mm
    zfg - Coordinate of the right geodesic end of the mandrel in mm
    alfainicio - winding angle at the initial winding coordinate (zi) in radians α 2
    ] − π=2; π=2[
    niu - Static friction coefficient µ
    lambda1 - λ parameter where λ = cµ and c 2 [0; 1]
    ds - increment for calculation along the geodesic paths in mm
    dsta - increment for calculation along the turnaround paths in mm
    b - bandwidth in mm
    NR - Number of rovings
    RW=b/NR - roving width in mm
    TEX - TEX value in g/km
    fvc - fibre volume content
    fmc - fibre mass content
    fibdens - fibre density in g=cm3
    resdens - resin density in g=cm3
    NP - Number of paths per tow (actual number of paths will be 4NP)
    vel - Machine velocity (multiplies the time that each command line takes to perform
    the axes movement)
    nomeoutput - Name of the new folder where outputs will be stored
    filepath - Filepath for where the new folder will be created
    gravartrajectorias - Specifies if the path trajectories are to be saved as a .txt. If
    saving is required then the variable should be equal to ’s’.
    cnc - Specifies if a CNC output is required. This relates to the calculations and the
    outputs. If it is required then the variable should be equal to ’s’.
    gravarcnc - Specifies if the CNC code output files are to be saved as a .mpf and .spf.
    If saving is required then the variable should be equal to ’s’.
    D - Fixed distance of the pay-out eye to the mandrel in mm
    sobre - Specifies if a overlapped output is required. This relates to the calculations
    and the outputs. If it is required then the variable should be equal to ’sobreposi¸c~ao1’
    if only one cycle is desired and ’sobreposi¸c~ao2’ if all cycles are required.
    <h2>B.3 Machine parameters input</h2>
    Reference positions
    RefA - Reference position of axis A
    RefX - Reference position of axis X
    RefY - Reference position of axis Y
    RefB - Reference position of axis B
    RefZ - Reference position of axis Z
    RefC - Reference position of axis C
    Dimensions
    Xmin - Minimum value of X
    Xmax - Maximum value of X
    Ymin - Minimum value of Y
    Ymax - Maximum value of Y
    Zmin - Minimum value of Z
    Zmax - Maximum value of Z
    Cmin - Minimum value of C
    Cmax - Maximum value of C
    POew - Pay out eye width
    POe - Pay out eye eccentricity
    YawR - Yaw radius
    Velocities
    VA - Maximum velocity of A in revolutions/min
    VX - Maximum velocity of X in m/s
    VY - Maximum velocity of Y in m/s
    VB - Maximum velocity of B in revolutions/min
    VZ - Maximum velocity of Z in m/s
    VC - Maximum velocity of C in revolutions/min
    Accelerations - defined as the maximum permissible velocity change of an axis
    between two control data records
    AA - Maximum acceleration of A in revolutions/min
    AX - Maximum acceleration of X in m/s
    AY - Maximum acceleration of Y in m/s
    AB - Maximum acceleration of B in revolutions/min
    AZ - Maximum acceleration of Z in m/s
    AC - Maximum acceleration of C in revolutions/min
    Resolutions
    RA - axis resolution of A in inc/revolution
    RX - axis resolution of X in inc/mm
    RY - axis resolution of Y in inc/mm
    RB - axis resolution of B in inc/revolution
    RZ - axis resolution of Z in inc/mm
    RC - axis resolution of C in inc/revolution
  </section>
<script type="module" src="js/index.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/matlab.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>